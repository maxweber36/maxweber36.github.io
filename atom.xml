<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿犇的自留地</title>
  
  <subtitle>YOLO：You Only Live Once</subtitle>
  <link href="https://maxweber36.github.io/atom.xml" rel="self"/>
  <link href="https://push.superfeedr.com/" rel="hub"/>
  <link href="https://maxweber36.github.io/"/>
  <updated>2025-12-05T09:51:37.449Z</updated>
  <id>https://maxweber36.github.io/</id>
  
  <author>
    <name>阿犇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>告别 Demo，拥抱 Production：Snapbar团队的Vibe Coding在生产环境的实践</title>
    <link href="https://maxweber36.github.io/2025/12/05/vibe-coding-in-production/"/>
    <id>https://maxweber36.github.io/2025/12/05/vibe-coding-in-production/</id>
    <published>2025-12-05T08:16:05.000Z</published>
    <updated>2025-12-05T09:51:37.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>这篇文章内容来自于 Snapbar 的 CTO Patrick Ellis 关于他们团队如何使用 AI 进行 Coding 的实践分享《Vibe Coding in Production: A Founder&#x2F;CTO’s 2025 AI Engineering Playbook (Cursor, Windsurf, Lovable)》。</p></blockquote><hr><p>Snapbar 是一个只有 8-13 人规模的团队，他们的 CTO Patrick Ellis 分享了团队如何在真实环境下使用 AI Coding 进行产品构建和迭代的实践。<br>AI 是一个强大的杠杆，用得好，可以带来很多收益。因此，对于 AI 能力的探索和应用，我觉得除了独立开发者或者一人公司之外，探索最多的应该就是像 Snapbar 这种小型初创团队，他们会在公司的各个层面利用 GenAI 杠杆，以提高团队效率。<br>使用 AI 进行 Coding 越多，我越感觉到现在真正重要的不是 Coding 本身，而是我和 AI 协同的工作流。所以，针对自己的场景和需求，摸索出自己和 AI 协同的工作流就成了重中之重。很多时候，与其说是在迭代产品的代码，不如说更重要的是迭代我的工作流，而产品的代码仅仅是我迭代工作流的一个自然产物而已。</p><hr><h2 id="视频信息"><a href="#视频信息" class="headerlink" title="视频信息"></a>视频信息</h2><ul><li><strong>Title</strong>: Vibe Coding in Production: A Founder&#x2F;CTO’s 2025 AI Engineering Playbook (Cursor, Windsurf, Lovable)</li></ul><ul><li><p><strong>Author</strong>: Patrick Ellis (CTO at Snapbar)</p></li><li><p><strong>Share Time</strong>: 2025&#x2F;3</p></li><li><p><strong>URL</strong>: <a href="https://www.youtube.com/watch?v=wW_nseHqalg">https://www.youtube.com/watch?v=wW_nseHqalg</a></p></li><li><p><strong>Overview</strong>: 本视频由 Snapbar 的 CTO Patrick Ellis 分享，展示了一个 8-13 人规模的早期团队如何通过全面采用生成式 AI（GenAI）重塑软件开发流程。核心论题在于重新定义“Vibe Coding”（氛围编码&#x2F;直觉编码）：它不仅是个人开发者的玩具，更是一种分层的生产级工作流。结论指出，通过将 <strong>Bolt&#x2F;Lovable</strong> 等快速原型工具赋予非技术人员，并结合 <strong>Cursor&#x2F;Windsurf</strong> 等 IDE 给工程师，可以大幅提升交付速度（例如用 AI 全自动完成 Slideshow 功能）。此外，视频还提出了利用 AI 实现低成本“产品化服务”（Productized Service）的商业模式，并强调了 <strong>Context（上下文）管理</strong> 是让 AI 模型从“玩具”变为“生产力工具”的关键。</p></li></ul><h2 id="内容主题"><a href="#内容主题" class="headerlink" title="内容主题"></a>内容主题</h2><h3 id="第一节：Vibe-Coding-的双层工作流：赋能非技术人员与重塑原型设计"><a href="#第一节：Vibe-Coding-的双层工作流：赋能非技术人员与重塑原型设计" class="headerlink" title="第一节：Vibe Coding 的双层工作流：赋能非技术人员与重塑原型设计"></a>第一节：Vibe Coding 的双层工作流：赋能非技术人员与重塑原型设计</h3><p>在这个开篇部分，Patrick Ellis 首先界定了 Snapbar 团队的背景——一个试图在公司各个层面利用 GenAI 杠杆的小型初创团队。他提出了一个核心观点：<strong>Vibe Coding 在生产环境中的应用并非单一模式，而是分层的。</strong></p><p><strong>第一层是针对非技术人员的赋能。</strong> Ellis 提到，他们广泛使用 <strong>Bolt.new</strong> 和 <strong>Lovable.dev</strong> 这类工具。这不仅仅是为了写代码，更是为了改变需求沟通的方式。在传统的软件开发中，产品经理（PM）或 CEO 可能需要使用 Figma 画图，写长篇的 PRD（产品需求文档），然后工程师再进行解读和翻译，这个过程中往往存在巨大的信息损耗。 在 Snapbar 的新流程中，CEO 或销售人员可以直接使用 Lovable 或 Bolt 通过自然语言描述构建出一个“看起来能工作”的原型。这个原型不仅是视觉上的，往往还包含基本交互。这种做法实际上替代了 Figma 的部分功能。非技术人员通过与 AI 的多轮对话，明确了他们想要什么，甚至通过 AI 生成一份基于该代码库的技术需求文档（Markdown 格式）。</p><p><strong>第二层是工程师的接管与生产化。</strong> 当非技术人员完成了 0 到 1 的探索后，工程师介入。对于一些生命周期较短、不需要长期维护的功能（例如视频中提到的“Slideshow&#x2F;Gallery”功能），工程师甚至可以直接将 Bolt 生成的代码迁移到 <strong>Cursor</strong> 或 <strong>Windsurf</strong> 中稍作修改就上线。Ellis 透露，他们本周即将上线的一个 Slideshow 功能，几乎完全是通过 Vibe Coding 构建的，他作为 CTO 只需要 Review PR（Pull Request）确保没有明显的安全漏洞即可。 但对于更复杂的系统（如核心 Dashboard），流程则不同。非技术人员的原型更多充当了“高保真需求说明书”的角色。工程师会查看 AI 生成的原型，理解意图，然后在一个更受控、更符合工程规范的环境中（使用 <strong>Claude Code</strong> 或 Cursor）从头构建或重构，以确保代码的可维护性和扩展性。</p><p><strong>核心洞察</strong>：这种分层结构解决了“AI 代码质量差”的顾虑。对于一次性或简单功能，容忍低质量代码以换取速度；对于核心业务，利用 AI 生成的原型作为沟通介质，消除歧义，再用传统的工程纪律去实现。</p><h3 id="第二节：增强型工程：AI-作为“主动式橡皮鸭”与结对程序员"><a href="#第二节：增强型工程：AI-作为“主动式橡皮鸭”与结对程序员" class="headerlink" title="第二节：增强型工程：AI 作为“主动式橡皮鸭”与结对程序员"></a>第二节：增强型工程：AI 作为“主动式橡皮鸭”与结对程序员</h3><p>当话题转回到专业工程师的日常开发时，Ellis 强调了 <strong>Augmented Traditional Development</strong>（增强型传统开发）的概念。这与随意的 Vibe Coding 不同，它要求保持软件工程的严谨性（Discipline）。</p><p>在这里，AI 模型（特别是 Claude 3.7, o3-mini 等）不再仅仅是代码生成器，而被视为一个 <strong>Thinking Partner</strong>（思考伙伴）。Ellis 引用了经典编程书籍《程序员修炼之道》（The Pragmatic Programmer）中的“橡皮鸭调试法”（Rubber Ducking）——即程序员通过向桌子上的一只橡皮鸭解释代码来发现 Bug。 Ellis 指出，现在的 AI 就是那个“会说话、有见解的橡皮鸭”。这种交互不仅是单向的输出，而是双向的迭代。你将复杂的架构问题抛给 AI，它能提供反馈、指出盲点甚至提供替代方案。他特别推崇 <strong>Claude Code</strong> 的官方文档中描述的迭代流程，认为这是目前将 AI 融入严肃工程的最佳实践。</p><p>在这个阶段，<strong>Deep Research</strong>（深度研究）也扮演了重要角色。Ellis 提到使用 <strong>OpenAI o3-mini</strong> 或 <strong>Deep Research</strong> 功能来快速学习新领域。例如，当团队需要引入一个新的库或技术栈时，不再需要花费数天阅读文档，而是让 AI 阅读所有相关资料，总结出最佳实践、陷阱和架构建议。 这种模式下，工程师的生产力得到了倍增，但前提是工程师必须具备 Code Review 的能力和架构设计的判断力。你不能盲目信任 AI 的输出，必须像审查初级工程师的代码一样审查 AI 的代码。这种“带有人类监督的 AI 结对编程”是构建可扩展、生产级代码库的关键。它保留了人类的决策权，但剥离了繁琐的样板代码编写和基础资料查阅工作。</p><h3 id="第三节：商业模式创新：AI-驱动的“产品化服务”与自动化解决方案"><a href="#第三节：商业模式创新：AI-驱动的“产品化服务”与自动化解决方案" class="headerlink" title="第三节：商业模式创新：AI 驱动的“产品化服务”与自动化解决方案"></a>第三节：商业模式创新：AI 驱动的“产品化服务”与自动化解决方案</h3><p>这部分是非常独特且具有战略意义的观点。Ellis 探讨了 AI 如何不仅仅改变写代码的方式，还能改变商业模式，具体来说是 <strong>Solutions Engineering</strong>（解决方案工程）的变革。</p><p>Snapbar 作为一个活动营销平台，服务的大型企业客户往往有定制化需求（例如定制品牌的微型网站 Micro-sites）。在过去，这通常需要昂贵的人力成本，即所谓的“Agency 模式”或咨询模式，这很难规模化（Scale）。SaaS 公司通常通过限制定制化来保持高利润率，但这会牺牲客户满意度或错失大单。</p><p>引入 GenAI 后，Snapbar 发现了一种 <strong>“Productized Service at Scale”</strong>（规模化的产品化服务）的新路径。 具体的做法是：利用 AI 工具（Cursor, Windsurf）极大降低“最后一公里”定制开发的成本。运营人员或解决方案工程师（甚至是非纯代码背景的人员）可以利用 AI 快速修改前端代码，满足客户的定制需求，而无需占用核心研发资源。 Ellis 在问答环节详细解释了技术实现：他们使用基于 Git 的工作流（Git-based workflow）。每个客户的定制需求会生成一个新的 Git Branch（分支），逻辑与主分支保持一致，但前端 UI&#x2F;UX 进行定制。利用 Netlify 等平台，可以为每个分支自动部署独立的子域名。 这种模式让公司既能享受 SaaS 的经常性收入（Recurring Revenue），又能通过高价值的定制服务（通过 AI 自动化降低成本）获取额外收益。AI 在这里不仅是效率工具，更是解锁新收入流（Revenue Stream）的杠杆。</p><h3 id="第四节：工具链精讲：MCP、FireCrawl-与-Context-管理"><a href="#第四节：工具链精讲：MCP、FireCrawl-与-Context-管理" class="headerlink" title="第四节：工具链精讲：MCP、FireCrawl 与 Context 管理"></a>第四节：工具链精讲：MCP、FireCrawl 与 Context 管理</h3><p>Ellis 花了大量篇幅详细拆解了他们的一线工具链，这是实操性最强的一部分。他认为 <strong>MCP (Model Context Protocol)</strong> 是目前的杀手级应用。</p><ol><li><strong>Browser Tools &amp; MCP</strong>：他提到通过 MCP 连接浏览器工具，让 AI（如 Claude Desktop 或 Cursor）能够直接获取浏览器的 Console Logs（控制台日志）、Network Logs（网络请求）甚至截屏。这意味着当你调试前端问题时，不需要手动复制粘贴错误信息，AI 可以“看到”你的浏览器发生了什么。</li><li><strong>FireCrawl</strong>：这是一个将任意网页转换为 Markdown 格式的工具。Ellis 强调，现在的 AI 模型虽然上下文窗口很大，但仍然有限且昂贵。直接喂 HTML 或 XML 包含太多噪音（标签、样式等）。FireCrawl 能提取网页的核心内容为 Markdown，极大地提高了 <strong>Signal-to-Noise Ratio</strong>（信噪比）。</li><li><strong>Context Hygiene（上下文卫生）</strong>：Ellis 提出了一个非常具体的工程实践——在代码库中建立一个 <code>docs/</code> 文件夹。<ul><li>当他要使用某个第三方库时，他会先用 FireCrawl 抓取该库的官方文档，存为 Markdown 文件放在 <code>docs/</code> 里。</li><li>如果有一份 80 页的 Google Doc API 文档，他也会导出为 Markdown 放入该文件夹。</li><li>在 Cursor 或 Windsurf 中，利用 <code>@docs</code> 或类似的引用功能，明确地将这些清洗过的知识喂给模型。</li></ul></li><li><strong>Super Whisper</strong>：为了实现极致的“Vibe Coding”，他使用 Super Whisper 进行语音输入。这个工具具备上下文感知能力，知道你是在终端（Terminal）里说话还是在写邮件，从而自动调整转写的格式（是输出 Shell 命令还是自然语言）。</li></ol><p>这一节的核心逻辑是：<strong>Trash in, Trash out</strong>。如果你希望 AI 输出高质量代码，你必须负责维护高质量的 Context。通过工具自动化地收集、清洗和组织 Context，是高级 AI 工程师的必备技能。</p><hr><h2 id="核心方法和流程"><a href="#核心方法和流程" class="headerlink" title="核心方法和流程"></a>核心方法和流程</h2><h4 id="Snapbar-的-AI-开发流水线-The-AI-Native-Pipeline"><a href="#Snapbar-的-AI-开发流水线-The-AI-Native-Pipeline" class="headerlink" title="Snapbar 的 AI 开发流水线 (The AI-Native Pipeline)"></a>Snapbar 的 AI 开发流水线 (The AI-Native Pipeline)</h4><p><strong>Step 1: 创意生成与初步研究 (Idea &amp; Research)</strong></p><ul><li><strong>输入</strong>：会议录音、头脑风暴笔记。</li><li><strong>工具</strong>：NotebookLM, Claude.</li><li><strong>操作</strong>：<ol><li>将会议录音转录文本喂给 NotebookLM，生成摘要或类似 Podcast 的音频回顾，帮助理清思路。</li><li>利用 Deep Research (o3-mini) 进行市场和技术栈调研。</li><li>将整理好的想法喂给 Claude，要求生成一份 <strong>Markdown 格式的 PRD (Product Requirements Document)</strong>。</li></ol></li></ul><p><strong>Step 2: 原型设计 (Prototyping - Layer 1)</strong></p><ul><li><strong>执行者</strong>：非技术人员 (CEO, Sales, PM)。</li><li><strong>工具</strong>：Bolt.new, Lovable.dev.</li><li><strong>操作</strong>：<ol><li>使用自然语言描述 Step 1 中的需求。</li><li>迭代生成可交互的 Web 应用原型。</li><li><strong>关键点</strong>：不仅是看图，要实际操作原型，验证逻辑。</li><li>输出：一个基于 React&#x2F;Vite 的临时代码库，或明确的功能演示。</li></ol></li></ul><p>这里是为您整理的 YouTube 视频 <strong>“Vibe Coding in Production: A Founder&#x2F;CTO’s 2025 AI Engineering Playbook”</strong> 的详细阅读版本。</p><hr><h3 id="1-Metadata"><a href="#1-Metadata" class="headerlink" title="1. Metadata"></a>1. Metadata</h3><ul><li><strong>Title</strong>: Vibe Coding in Production: A Founder&#x2F;CTO’s 2025 AI Engineering Playbook (Cursor, Windsurf, Lovable)</li><li><strong>Author</strong>: Patrick Ellis (CTO at Snapbar)</li><li><strong>URL</strong>: <a href="https://www.youtube.com/watch?v=wW_nseHqalg">https://www.youtube.com/watch?v=wW_nseHqalg</a></li><li><strong>Overview</strong>: 本视频由 Snapbar 的 CTO Patrick Ellis 分享，展示了一个 8-13 人规模的早期团队如何通过全面采用生成式 AI（GenAI）重塑软件开发流程。核心论题在于重新定义“Vibe Coding”（氛围编码&#x2F;直觉编码）：它不仅是个人开发者的玩具，更是一种分层的生产级工作流。结论指出，通过将 <strong>Bolt&#x2F;Lovable</strong> 等快速原型工具赋予非技术人员，并结合 <strong>Cursor&#x2F;Windsurf</strong> 等 IDE 给工程师，可以大幅提升交付速度（例如用 AI 全自动完成 Slideshow 功能）。此外，视频还提出了利用 AI 实现低成本“产品化服务”（Productized Service）的商业模式，并强调了 <strong>Context（上下文）管理</strong> 是让 AI 模型从“玩具”变为“生产力工具”的关键。</li></ul><hr><h3 id="2-按主题梳理"><a href="#2-按主题梳理" class="headerlink" title="2. 按主题梳理"></a>2. 按主题梳理</h3><h4 id="00-00-Vibe-Coding-的双层工作流：赋能非技术人员与重塑原型设计"><a href="#00-00-Vibe-Coding-的双层工作流：赋能非技术人员与重塑原型设计" class="headerlink" title="[00:00] Vibe Coding 的双层工作流：赋能非技术人员与重塑原型设计"></a>[<a href="http://www.youtube.com/watch?v=wW_nseHqalg&t=0">00:00</a>] Vibe Coding 的双层工作流：赋能非技术人员与重塑原型设计</h4><p>在这个开篇部分，Patrick Ellis 首先界定了 Snapbar 团队的背景——一个试图在公司各个层面利用 GenAI 杠杆的小型初创团队。他提出了一个核心观点：<strong>Vibe Coding 在生产环境中的应用并非单一模式，而是分层的。</strong></p><p><strong>第一层是针对非技术人员的赋能。</strong> Ellis 提到，他们广泛使用 <strong>Bolt.new</strong> 和 <strong>Lovable.dev</strong> 这类工具。这不仅仅是为了写代码，更是为了改变需求沟通的方式。在传统的软件开发中，产品经理（PM）或 CEO 可能需要使用 Figma 画图，写长篇的 PRD（产品需求文档），然后工程师再进行解读和翻译，这个过程中往往存在巨大的信息损耗。 在 Snapbar 的新流程中，CEO 或销售人员可以直接使用 Lovable 或 Bolt 通过自然语言描述构建出一个“看起来能工作”的原型。这个原型不仅是视觉上的，往往还包含基本交互。这种做法实际上替代了 Figma 的部分功能。非技术人员通过与 AI 的多轮对话，明确了他们想要什么，甚至通过 AI 生成一份基于该代码库的技术需求文档（Markdown 格式）。</p><p><strong>第二层是工程师的接管与生产化。</strong> 当非技术人员完成了 0 到 1 的探索后，工程师介入。对于一些生命周期较短、不需要长期维护的功能（例如视频中提到的“Slideshow&#x2F;Gallery”功能），工程师甚至可以直接将 Bolt 生成的代码迁移到 <strong>Cursor</strong> 或 <strong>Windsurf</strong> 中稍作修改就上线。Ellis 透露，他们本周即将上线的一个 Slideshow 功能，几乎完全是通过 Vibe Coding 构建的，他作为 CTO 只需要 Review PR（Pull Request）确保没有明显的安全漏洞即可。 但对于更复杂的系统（如核心 Dashboard），流程则不同。非技术人员的原型更多充当了“高保真需求说明书”的角色。工程师会查看 AI 生成的原型，理解意图，然后在一个更受控、更符合工程规范的环境中（使用 <strong>Claude Code</strong> 或 Cursor）从头构建或重构，以确保代码的可维护性和扩展性。</p><p><strong>核心洞察</strong>：这种分层结构解决了“AI 代码质量差”的顾虑。对于一次性或简单功能，容忍低质量代码以换取速度；对于核心业务，利用 AI 生成的原型作为沟通介质，消除歧义，再用传统的工程纪律去实现。</p><h4 id="04-55-增强型工程：AI-作为“主动式橡皮鸭”与结对程序员"><a href="#04-55-增强型工程：AI-作为“主动式橡皮鸭”与结对程序员" class="headerlink" title="[04:55] 增强型工程：AI 作为“主动式橡皮鸭”与结对程序员"></a>[<a href="http://www.youtube.com/watch?v=wW_nseHqalg&t=295">04:55</a>] 增强型工程：AI 作为“主动式橡皮鸭”与结对程序员</h4><p>当话题转回到专业工程师的日常开发时，Ellis 强调了 <strong>Augmented Traditional Development</strong>（增强型传统开发）的概念。这与随意的 Vibe Coding 不同，它要求保持软件工程的严谨性（Discipline）。</p><p>在这里，AI 模型（特别是 Claude 3.7, o3-mini 等）不再仅仅是代码生成器，而被视为一个 <strong>Thinking Partner</strong>（思考伙伴）。Ellis 引用了经典编程书籍《程序员修炼之道》（The Pragmatic Programmer）中的“橡皮鸭调试法”（Rubber Ducking）——即程序员通过向桌子上的一只橡皮鸭解释代码来发现 Bug。 Ellis 指出，现在的 AI 就是那个“会说话、有见解的橡皮鸭”。这种交互不仅是单向的输出，而是双向的迭代。你将复杂的架构问题抛给 AI，它能提供反馈、指出盲点甚至提供替代方案。他特别推崇 <strong>Claude Code</strong> 的官方文档中描述的迭代流程，认为这是目前将 AI 融入严肃工程的最佳实践。</p><p>在这个阶段，<strong>Deep Research</strong>（深度研究）也扮演了重要角色。Ellis 提到使用 <strong>OpenAI o3-mini</strong> 或 <strong>Deep Research</strong> 功能来快速学习新领域。例如，当团队需要引入一个新的库或技术栈时，不再需要花费数天阅读文档，而是让 AI 阅读所有相关资料，总结出最佳实践、陷阱和架构建议。 这种模式下，工程师的生产力得到了倍增，但前提是工程师必须具备 Code Review 的能力和架构设计的判断力。你不能盲目信任 AI 的输出，必须像审查初级工程师的代码一样审查 AI 的代码。这种“带有人类监督的 AI 结对编程”是构建可扩展、生产级代码库的关键。它保留了人类的决策权，但剥离了繁琐的样板代码编写和基础资料查阅工作。</p><h4 id="06-29-商业模式创新：AI-驱动的“产品化服务”与自动化解决方案"><a href="#06-29-商业模式创新：AI-驱动的“产品化服务”与自动化解决方案" class="headerlink" title="[06:29] 商业模式创新：AI 驱动的“产品化服务”与自动化解决方案"></a>[<a href="http://www.youtube.com/watch?v=wW_nseHqalg&t=389">06:29</a>] 商业模式创新：AI 驱动的“产品化服务”与自动化解决方案</h4><p>这部分是非常独特且具有战略意义的观点。Ellis 探讨了 AI 如何不仅仅改变写代码的方式，还能改变商业模式，具体来说是 <strong>Solutions Engineering</strong>（解决方案工程）的变革。</p><p>Snapbar 作为一个活动营销平台，服务的大型企业客户往往有定制化需求（例如定制品牌的微型网站 Micro-sites）。在过去，这通常需要昂贵的人力成本，即所谓的“Agency 模式”或咨询模式，这很难规模化（Scale）。SaaS 公司通常通过限制定制化来保持高利润率，但这会牺牲客户满意度或错失大单。</p><p>引入 GenAI 后，Snapbar 发现了一种 <strong>“Productized Service at Scale”</strong>（规模化的产品化服务）的新路径。 具体的做法是：利用 AI 工具（Cursor, Windsurf）极大降低“最后一公里”定制开发的成本。运营人员或解决方案工程师（甚至是非纯代码背景的人员）可以利用 AI 快速修改前端代码，满足客户的定制需求，而无需占用核心研发资源。 Ellis 在问答环节详细解释了技术实现：他们使用基于 Git 的工作流（Git-based workflow）。每个客户的定制需求会生成一个新的 Git Branch（分支），逻辑与主分支保持一致，但前端 UI&#x2F;UX 进行定制。利用 Netlify 等平台，可以为每个分支自动部署独立的子域名。 这种模式让公司既能享受 SaaS 的经常性收入（Recurring Revenue），又能通过高价值的定制服务（通过 AI 自动化降低成本）获取额外收益。AI 在这里不仅是效率工具，更是解锁新收入流（Revenue Stream）的杠杆。</p><h4 id="09-55-工具链精讲：MCP、FireCrawl-与-Context-管理"><a href="#09-55-工具链精讲：MCP、FireCrawl-与-Context-管理" class="headerlink" title="[09:55] 工具链精讲：MCP、FireCrawl 与 Context 管理"></a>[<a href="http://www.youtube.com/watch?v=wW_nseHqalg&t=595">09:55</a>] 工具链精讲：MCP、FireCrawl 与 Context 管理</h4><p>Ellis 花了大量篇幅详细拆解了他们的一线工具链，这是实操性最强的一部分。他认为 <strong>MCP (Model Context Protocol)</strong> 是目前的杀手级应用。</p><ol><li><strong>Browser Tools &amp; MCP</strong>：他提到通过 MCP 连接浏览器工具，让 AI（如 Claude Desktop 或 Cursor）能够直接获取浏览器的 Console Logs（控制台日志）、Network Logs（网络请求）甚至截屏。这意味着当你调试前端问题时，不需要手动复制粘贴错误信息，AI 可以“看到”你的浏览器发生了什么。</li><li><strong>FireCrawl</strong>：这是一个将任意网页转换为 Markdown 格式的工具。Ellis 强调，现在的 AI 模型虽然上下文窗口很大，但仍然有限且昂贵。直接喂 HTML 或 XML 包含太多噪音（标签、样式等）。FireCrawl 能提取网页的核心内容为 Markdown，极大地提高了 <strong>Signal-to-Noise Ratio</strong>（信噪比）。</li><li><strong>Context Hygiene（上下文卫生）</strong>：Ellis 提出了一个非常具体的工程实践——在代码库中建立一个 <code>docs/</code> 文件夹。<ul><li>当他要使用某个第三方库时，他会先用 FireCrawl 抓取该库的官方文档，存为 Markdown 文件放在 <code>docs/</code> 里。</li><li>如果有一份 80 页的 Google Doc API 文档，他也会导出为 Markdown 放入该文件夹。</li><li>在 Cursor 或 Windsurf 中，利用 <code>@docs</code> 或类似的引用功能，明确地将这些清洗过的知识喂给模型。</li></ul></li><li><strong>Super Whisper</strong>：为了实现极致的“Vibe Coding”，他使用 Super Whisper 进行语音输入。这个工具具备上下文感知能力，知道你是在终端（Terminal）里说话还是在写邮件，从而自动调整转写的格式（是输出 Shell 命令还是自然语言）。</li></ol><p>这一节的核心逻辑是：<strong>Trash in, Trash out</strong>。如果你希望 AI 输出高质量代码，你必须负责维护高质量的 Context。通过工具自动化地收集、清洗和组织 Context，是高级 AI 工程师的必备技能。</p><hr><h3 id="核心方法和流程-1"><a href="#核心方法和流程-1" class="headerlink" title="核心方法和流程"></a>核心方法和流程</h3><h4 id="Snapbar-的-AI-开发流水线-The-AI-Native-Pipeline-1"><a href="#Snapbar-的-AI-开发流水线-The-AI-Native-Pipeline-1" class="headerlink" title="Snapbar 的 AI 开发流水线 (The AI-Native Pipeline)"></a>Snapbar 的 AI 开发流水线 (The AI-Native Pipeline)</h4><p><strong>Step 1: 创意生成与初步研究 (Idea &amp; Research)</strong></p><ul><li><strong>输入</strong>：会议录音、头脑风暴笔记。</li><li><strong>工具</strong>：NotebookLM, Claude.</li><li><strong>操作</strong>：<ol><li>将会议录音转录文本喂给 NotebookLM，生成摘要或类似 Podcast 的音频回顾，帮助理清思路。</li><li>利用 Deep Research (o3-mini) 进行市场和技术栈调研。</li><li>将整理好的想法喂给 Claude，要求生成一份 <strong>Markdown 格式的 PRD (Product Requirements Document)</strong>。</li></ol></li></ul><p><strong>Step 2: 原型设计 (Prototyping - Layer 1)</strong></p><ul><li><strong>执行者</strong>：非技术人员 (CEO, Sales, PM)。</li><li><strong>工具</strong>：Bolt.new, Lovable.dev.</li><li><strong>操作</strong>：<ol><li>使用自然语言描述 Step 1 中的需求。</li><li>迭代生成可交互的 Web 应用原型。</li><li><strong>关键点</strong>：不仅是看图，要实际操作原型，验证逻辑。</li><li>输出：一个基于 React&#x2F;Vite 的临时代码库，或明确的功能演示。</li></ol></li></ul><p><strong>Step 3: 工程接手与生产化 (Engineering Handover - Layer 2)</strong></p><ul><li><strong>执行者</strong>：软件工程师。</li><li><strong>工具</strong>：Cursor, Windsurf, Claude Code, FireCrawl.</li><li><strong>路径 A (简单功能&#x2F;一次性)</strong>：<ol><li>直接导出 Bolt&#x2F;Lovable 的代码。</li><li>在 Cursor 中进行 Code Review，修复明显 Bug。</li><li>部署上线 (Production)。</li></ol></li><li><strong>路径 B (核心复杂功能)</strong>：<ol><li>工程师阅读原型代码，理解意图，将其视为“动态的 Figma”。</li><li>在主代码库中，利用 Claude Code 辅助，按照严格的架构模式重新编写。</li><li><strong>Context 注入</strong>：使用 FireCrawl 抓取最新的库文档放入 <code>docs/</code> 目录，供 AI 参考。</li></ol></li></ul><p><strong>Step 4: 企业级定制 (Enterprise Customization)</strong></p><ul><li><strong>场景</strong>：大客户需要修改 UI&#x2F;Theme。</li><li><strong>操作</strong>：<ol><li>基于主分支 (Core Branch) 创建客户专用分支 (Customer Branch)。</li><li>运营&#x2F;解决方案工程师使用 AI 工具（Cursor）修改前端代码（如 CSS, Layout）。</li><li>Netlify 自动部署该分支到特定子域名 (e.g., <code>clientA.snapbar.com</code>)。</li><li><strong>注释</strong>：后端逻辑保持统一，仅前端隔离，便于维护。</li></ol></li></ul><h2 id="一些其他重要的-Tips"><a href="#一些其他重要的-Tips" class="headerlink" title="一些其他重要的 Tips"></a>一些其他重要的 Tips</h2><h4 id="The-Context-Empathy-Model-上下文同理心模型"><a href="#The-Context-Empathy-Model-上下文同理心模型" class="headerlink" title="The Context Empathy Model (上下文同理心模型)"></a>The Context Empathy Model (上下文同理心模型)</h4><ul><li><strong>定义</strong>：这就好比与一个完全失忆但在某个房间里有无限知识库的天才合作。这个天才（AI）不知道你的项目历史，不知道你的昨天，只知道你现在喂给他的东西。</li><li><strong>核心逻辑</strong>：<ul><li><strong>Limited Horizon</strong>：模型虽然有训练数据的“长期记忆”，但在你的具体任务上，它只有“短期记忆”（Context Window）。</li><li><strong>Explicit Anchoring</strong>：你必须显式地（Explicitly）告诉它参考什么。Ellis 强调，当你指望模型写出好代码时，必须问自己：“我给它的 Context（文档、代码片段、对话历史）足以支撑它得出正确结论吗？”</li><li><strong>Action</strong>：如果结果不好，不要怪模型笨，先怪 Context 没给够。建立 <code>docs/</code> 目录，使用 MCP 抓取实时数据，都是为了增强这种“同理心”</li></ul></li></ul><h4 id="Tech-Stack-Selection-for-AI-面向-AI-的选型策略"><a href="#Tech-Stack-Selection-for-AI-面向-AI-的选型策略" class="headerlink" title="Tech Stack Selection for AI (面向 AI 的选型策略)"></a>Tech Stack Selection for AI (面向 AI 的选型策略)</h4><ul><li><strong>定义</strong>：在选择技术栈时，不再只考虑性能或个人喜好，而是优先考虑 <strong>“LLM Friendliness”</strong>（大模型友好度）。</li><li><strong>核心逻辑</strong>：<ul><li>Ellis 明确指出，使用 TypeScript, React, Next.js, Node.js 等主流技术栈，AI 的表现会显著优于冷门语言。</li><li><strong>Training Data Density（训练数据密度）</strong>：主流框架在训练数据中占比极大，模型见过无数种写法，因此能输出高质量（80% Baseline）的代码。</li><li><strong>Style Paradigm</strong>：模型不仅是写代码，还能模仿最佳设计模式（Patterns）。使用主流栈，模型会自然倾向于使用社区公认的最佳实践。</li><li><strong>结论</strong>：在 2025 年，选择一个 AI 擅长的技术栈，等于一开始就拥有了一个高级架构师队友。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Vibe Coding" scheme="https://maxweber36.github.io/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>🔄 Vibe Coding 的开发工作流</title>
    <link href="https://maxweber36.github.io/2025/12/03/Vibe-Coding-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://maxweber36.github.io/2025/12/03/Vibe-Coding-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2025-12-03T08:24:29.000Z</published>
    <updated>2025-12-03T09:42:46.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>这篇文章内容来自于 Y Combinator 的视频《How To Get The Most Out Of Vibe Coding》的启发。</p></blockquote><h2 id="📚-系列文章导航"><a href="#📚-系列文章导航" class="headerlink" title="📚 系列文章导航"></a>📚 系列文章导航</h2><p>本系列文章基于 Y Combinator 的《How To Get The Most Out Of Vibe Coding》视频，深入探讨与 AI 协同编程的最佳实践：</p><ol><li><p><strong><a href="/2025/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84-Vibe-Coding-%E6%9D%A5%E8%87%AA-YC-Startup-Founders-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE/">✨ 如何更好的 Vibe Coding？—来自 YC Startup Founders 的实践建议</a></strong> - 深入分析 Vibe Coding 的核心原则和进阶技巧</p></li><li><p><strong><a href="/2025/12/03/%E5%92%8C-AI-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%8D%8F%E5%90%8C/">🤝 在 Coding 的时候，我们应该和 AI 如何进行有效的协同</a></strong> - 分析与 AI 协同的核心思维模型和工作原则</p></li><li><p><strong><a href="/2025/12/03/Vibe-Coding-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/">🔄 Vibe Coding 的开发工作流</a></strong> - 详细介绍标准化的 Vibe Coding 开发流程和调试方法（本文）</p></li></ol><hr><h2 id="视频信息"><a href="#视频信息" class="headerlink" title="视频信息"></a>视频信息</h2><p><img src="/images/what-is-right-posture-of-vibe-coding/vibe-coding.png" alt="Vibe Coding"></p><ul><li>Title: How To Get The Most Out Of Vibe Coding | Startup School (如何通过“Vibe Coding”获得最大收益)</li><li>Author: Y Combinator (主讲人: Tom Blomfield, YC Partner)</li><li>URL: <a href="https://www.youtube.com/watch?v=BJjsfNO5JTo">https://www.youtube.com/watch?v=BJjsfNO5JTo</a></li></ul><h2 id="Vibe-Coding-标准开发工作流-The-Golden-Workflow"><a href="#Vibe-Coding-标准开发工作流-The-Golden-Workflow" class="headerlink" title="Vibe Coding 标准开发工作流 (The Golden Workflow)"></a>Vibe Coding 标准开发工作流 (The Golden Workflow)</h2><p>此流程旨在最大限度减少 AI 产生的错误，并保持代码库的健康。</p><ul><li><p>Step 1: 制定“主计划” (The Master Plan)</p><ul><li><p>操作：在项目根目录创建一个 PLAN.md。</p></li><li><p>内容：与 LLM 对话，生成项目功能的完整列表和实施步骤。</p></li><li><p>细化：人工审查，标记 [Won’t Do] 或 [Out of Scope] 的条目。</p></li><li><p><em>注释：这个文件是整个开发的导航图，避免 AI 迷失方向。</em></p></li></ul></li><li><p>Step 2: 准备 Git 环境 (Clean Slate)</p><ul><li><p>操作：确保 git status 是干净的。</p></li><li><p>原则：永远不要在未提交的代码之上开始新功能开发。</p></li></ul></li><li><p>Step 3: 逐节实施 (Section-by-Section Implementation)</p><ul><li><p>操作：引用 PLAN.md，指示 AI “Implement Section 2 only”（只实现第二节）。</p></li><li><p>关键：克制一次性完成所有的冲动。</p></li></ul></li><li><p>Step 4: 验证与测试 (Verify &amp; Test)</p><ul><li><p>操作：运行高层次集成测试，或手动点击验证功能。</p></li><li><p>检查：确认没有破坏现有的功能（No Regressions）。</p></li></ul></li><li><p>Step 5: 提交或重置 (Commit or Reset)</p><ul><li><p>分支 A (成功)：如果工作正常 -&gt; git commit -m “Implement Section 2” -&gt; 更新 PLAN.md 标记为完成。</p></li><li><p>分支 B (失败)：如果 AI 陷入循环或破坏了逻辑 -&gt; 执行 git reset –hard。</p></li><li><p><em>注释：不要试图修复 AI 写烂的代码，直接重置，调整 Prompt 后重新生成。</em></p></li></ul></li><li><p>Step 6: 重复循环</p><ul><li>回到 Step 3，继续下一节。</li></ul></li></ul><h2 id="AI-Debuging-流程"><a href="#AI-Debuging-流程" class="headerlink" title="AI Debuging 流程"></a>AI Debuging 流程</h2><ul><li><p>Step 1: 收集证据</p><ul><li><p>直接复制错误日志（Server logs &#x2F; Console errors）。</p></li><li><p>或者截图 UI 错误。</p></li></ul></li><li><p>Step 2: 初步诊断</p><ul><li><p>将证据粘贴给 LLM。</p></li><li><p>指令：”What could be causing this? List 3 possible reasons before coding.”（先列出 3 个原因，不要直接写代码）。</p></li></ul></li><li><p>Step 3: 尝试修复 (Single Shot)</p><ul><li>让 AI 根据最可能的原因生成修复代码。</li></ul></li><li><p>Step 4: 评估结果</p><ul><li><p>成功：运行测试 -&gt; 提交。</p></li><li><p>失败：立即 Reset。不要在修复补丁上再打补丁。</p></li><li><p>策略调整：如果多次失败，考虑切换模型（如从 Claude 切到 Gemini），或在干净代码库上提供更详细的上下文。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="Vibe Coding" scheme="https://maxweber36.github.io/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>🤝 在 Coding 的时候，我们应该和 AI如何进行有效的协同</title>
    <link href="https://maxweber36.github.io/2025/12/03/%E5%92%8C-AI-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%8D%8F%E5%90%8C/"/>
    <id>https://maxweber36.github.io/2025/12/03/%E5%92%8C-AI-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%8D%8F%E5%90%8C/</id>
    <published>2025-12-03T08:09:13.000Z</published>
    <updated>2025-12-03T09:44:10.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>这篇文章内容来自于 Y Combinator 的视频《How To Get The Most Out Of Vibe Coding》。</p></blockquote><h2 id="📚-系列文章导航"><a href="#📚-系列文章导航" class="headerlink" title="📚 系列文章导航"></a>📚 系列文章导航</h2><p>本系列文章基于 Y Combinator 的《How To Get The Most Out Of Vibe Coding》视频，深入探讨与 AI 协同编程的最佳实践：</p><ol><li><p><strong><a href="/2025/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84-Vibe-Coding-%E6%9D%A5%E8%87%AA-YC-Startup-Founders-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE/">✨ 如何更好的 Vibe Coding？—来自 YC Startup Founders 的实践建议</a></strong> - 深入分析 Vibe Coding 的核心原则和进阶技巧</p></li><li><p><strong><a href="/2025/12/03/%E5%92%8C-AI-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%8D%8F%E5%90%8C/">🤝 在 Coding 的时候，我们应该和 AI 如何进行有效的协同</a></strong> - 分析与 AI 协同的核心思维模型和工作原则（本文）</p></li><li><p><strong><a href="/2025/12/03/Vibe-Coding-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/">🔄 Vibe Coding 的开发工作流</a></strong> - 详细介绍标准化的 Vibe Coding 开发流程和调试方法</p></li></ol><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我最近通过 Vibe Coding 的方式，构建了好几个产品，也确实感受到了 Vibe Coding 的强大，但是并不意味着，使用 AI 构建产品就没有门槛；这并不意味着我可以使用一句话就可以轻易构建出一个可用的产品。</p><p>当我真正在使用 AI 去构建产品的时候，我发现了很多问题，也发现了很多局限。但是这些并不意味着我们应该回归传统的人工编码的方式。恰恰因为如此，我觉得 Vibe Coding 或者更准确的说，和 AI 进行协同编程的领域，有很多值得学习的地方，需要不断通过练习而可以获得显著精进的技能。</p><p>最近在看 YC 的 《How To Get The Most Out Of Vibe Coding》，收益匪浅。</p><h2 id="视频信息"><a href="#视频信息" class="headerlink" title="视频信息"></a>视频信息</h2><p><img src="/images/what-is-right-posture-of-vibe-coding/vibe-coding.png" alt="Vibe Coding"></p><ul><li>Title: How To Get The Most Out Of Vibe Coding | Startup School (如何通过“Vibe Coding”获得最大收益)</li><li>Author: Y Combinator (主讲人: Tom Blomfield, YC Partner)</li><li>URL: <a href="https://www.youtube.com/watch?v=BJjsfNO5JTo">https://www.youtube.com/watch?v=BJjsfNO5JTo</a></li></ul><h2 id="我们在-Coding-的时候，我们应该如何和-AI-进行协同？"><a href="#我们在-Coding-的时候，我们应该如何和-AI-进行协同？" class="headerlink" title="我们在 Coding 的时候，我们应该如何和 AI 进行协同？"></a>我们在 Coding 的时候，我们应该如何和 AI 进行协同？</h2><ol><li>The “Manager of Junior Developers” Model (初级开发者管理模型)<br>核心概念： 你不应将 AI 视为一个能读懂你心思的“超级天才”，而应将其视为一个才华横溢但经验不足、容易分心且极其听话的“初级实习生”。</li></ol><ul><li><p>深度解析：</p><ul><li><p>明确的指令（Clear Instructions）：就像带实习生一样，如果你给出的任务模棱两可，实习生就会产出错误的结果。你需要提供极其详尽的上下文、文档和约束条件。视频中提到的“下载文档到本地”和“编写 Instruction 文件”正是为了给这位实习生提供工作手册。</p></li><li><p>代码审查（Code Review）：你不能盲目信任实习生的代码。虽然你可能不逐行检查语法，但你需要检查逻辑是否合理，是否引入了不必要的变动。这就是为什么 Tom 强调要看 diff，要警惕 AI 修改了它不该修改的地方（Unrelated logic changes）。</p></li><li><p>任务拆解（Task Breakdown）：你不会把整个系统架构扔给实习生让他一天做完。你会把任务拆解成“Section 2”、“Section 3”这样的小块。Vibe Coding 也是如此，必须将宏大的愿景拆解为 AI 可以消化和执行的微小任务单元。</p></li></ul></li></ul><ol start="2"><li>The “Clean Slate” Protocol (白板协议)<br>核心概念： 对抗 AI 编程中熵增（Entropy）的唯一方法是保持极端的无状态性（Statelessness）和可逆性（Reversibility）。</li></ol><ul><li><p>深度解析：</p><ul><li><p>累积误差理论（Accumulated Error Theory）：视频中反复提到 “Layers of bad code” 或 “Layers of craft”。当 AI 犯错并试图自我修正时，它往往不会删除错误的代码，而是添加更多的逻辑来“绕过”错误。经过三四次“修复”后，代码库就会变成一坨不可维护的泥潭。</p></li><li><p>重置即止损：这个模型要求开发者克服“沉没成本谬误”。当你花了 10 分钟让 AI 修复一个 Bug 却没成功时，本能是继续修。但“白板协议”要求你立即 git reset –hard。</p></li><li><p>蒸馏解决方案：即使你在第 5 次 Prompt 时找到了解决方案，也不要保留那份经过 5 次修改的代码。你应该提取出那个最终的解决方案逻辑，回滚代码库，然后在干净的“白板”上一次性应用这个正确的方案。这保证了代码库永远只包含“经过深思熟虑的正确代码”，而不是“试错过程的遗迹”。</p></li></ul></li></ul><ol start="3"><li>The “Language-Driven Architecture” (语言驱动架构)<br>核心概念： 编程语言的选择不再仅仅取决于性能或个人喜好，而是取决于该语言在 LLM 训练数据中的密度和一致性。同时，软件架构应向“AI 易于理解”的方向演进。</li></ol><ul><li><p>深度解析：</p><ul><li><p>训练数据决定生产力：Tom 选择 Ruby on Rails 的逻辑非常有启发性。Rails 作为一个老框架，其“强约定”（Strong Conventions）意味着全球的 Rails 代码长得都很像。这意味着 LLM 学习到的模式非常统一且高质量。相反，像 Rust 这样灵活且较新的语言，或者配置极其自由的框架，LLM 的表现就会下降。在 Vibe Coding 时代，选择一个“AI 熟悉”的技术栈可能比选择一个“性能最快”的技术栈更重要。</p></li><li><p>模块化作为认知边界：AI 的上下文窗口（Context Window）虽然在变大，但注意力机制（Attention）在处理过量信息时仍会衰减。将系统设计为模块化、微服务或清晰的 API 边界，实际上是人为地为 AI 划定“认知范围”。当 AI 只需要关注一个模块内部的逻辑，且外部接口锁定时，它的表现会呈指数级上升。这不仅仅是为了代码解耦，更是为了适应 AI 的工作特性</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="Vibe Coding" scheme="https://maxweber36.github.io/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>✨ 什么才是 Vibe Coding 的正确姿势？---来自 YC Startup Founders 的实践建议</title>
    <link href="https://maxweber36.github.io/2025/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84-Vibe-Coding-%E6%9D%A5%E8%87%AA-YC-Startup-Founders-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE/"/>
    <id>https://maxweber36.github.io/2025/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84-Vibe-Coding-%E6%9D%A5%E8%87%AA-YC-Startup-Founders-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE/</id>
    <published>2025-12-03T07:55:10.000Z</published>
    <updated>2025-12-03T09:27:11.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>这篇文章内容来自于 Y Combinator 的视频《How To Get The Most Out Of Vibe Coding》的启发。</p></blockquote><h2 id="📚-系列文章导航"><a href="#📚-系列文章导航" class="headerlink" title="📚 系列文章导航"></a>📚 系列文章导航</h2><p>本系列文章基于 Y Combinator 的《How To Get The Most Out Of Vibe Coding》视频，深入探讨与 AI 协同编程的最佳实践：</p><ol><li><p><strong><a href="/2025/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84-Vibe-Coding-%E6%9D%A5%E8%87%AA-YC-Startup-Founders-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE/">✨ 如何更好的 Vibe Coding？—来自 YC Startup Founders 的实践建议</a></strong> - 深入分析 Vibe Coding 的核心原则和进阶技巧（本文）</p></li><li><p><strong><a href="/2025/12/03/%E5%92%8C-AI-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%8D%8F%E5%90%8C/">🤝 在 Coding 的时候，我们应该和 AI如何进行有效的协同</a></strong> - 分析与 AI 协同的核心思维模型和工作原则</p></li><li><p><strong><a href="/2025/12/03/Vibe-Coding-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/">🔄 Vibe Coding 的开发工作流</a></strong> - 详细介绍标准化的 Vibe Coding 开发流程和调试方法</p></li></ol><hr><p>我最近通过 Vibe Coding 的方式，构建了好几个产品，也确实感受到了 Vibe Coding 的强大，但是并不意味着，使用 AI 构建产品就没有门槛；这并不意味着我可以使用一句话就可以轻易构建出一个可用的产品。</p><p>当我真正在使用 AI 去构建产品的时候，我发现了很多问题，也发现了很多局限。但是这些并不意味着我们应该回归传统的人工编码的方式。恰恰因为如此，我觉得 Vibe Coding 或者更准确的说，和 AI 进行协同编程的领域，有很多值得学习的地方，需要不断通过练习而可以获得显著精进的技能。</p><p>就像这个视频中 YC 的合伙人 Tom Blomfield 说的那样：“We’re trying to use these tools to get the best results. ”（我们的目标是利用这些工具获得最佳结果，而不是纠结于定义）。这个视频更新时间是 比较久远了，但是里面的实践建议，放到今天，依然非常有用。</p><p><strong>最高效的 Vibe Coding 技巧，其实就是专业软件工程师一直以来遵循的最佳实践</strong></p><hr><h2 id="视频信息"><a href="#视频信息" class="headerlink" title="视频信息"></a>视频信息</h2><p><img src="/images/what-is-right-posture-of-vibe-coding/vibe-coding.png" alt="Vibe Coding"></p><ul><li>Title: How To Get The Most Out Of Vibe Coding | Startup School (如何通过“Vibe Coding”获得最大收益)</li><li>Author: Y Combinator (主讲人: Tom Blomfield, YC Partner)</li><li>URL: <a href="https://www.youtube.com/watch?v=BJjsfNO5JTo">https://www.youtube.com/watch?v=BJjsfNO5JTo</a></li><li>Overview: 视频探讨了如何将“Vibe Coding”（利用 AI 工具辅助编程的直觉式开发）转化为一种专业、高效的工程实践。核心论点在于，最好的 AI 编程技巧本质上就是优秀的软件工程原则。Tom 强调，不要把 AI 仅仅当作代码生成器，而应将其视为需要明确指令、详尽规划和严格代码审查的“初级开发人员”。结论是，通过建立结构化的工作流（如编写 Markdown 计划、从测试出发、频繁重置上下文、保持模块化），开发者可以利用 Cursor、Windsurf 等工具极大幅度地提升构建速度，同时避免生成不可维护的“垃圾代码”。</li></ul><h2 id="内容主题"><a href="#内容主题" class="headerlink" title="内容主题"></a>内容主题</h2><h3 id="第一节：Vibe-Coding-的本质与起步策略"><a href="#第一节：Vibe-Coding-的本质与起步策略" class="headerlink" title="第一节：Vibe Coding 的本质与起步策略"></a>第一节：Vibe Coding 的本质与起步策略</h3><p><strong>Vibe Coding 的定义与心态转变</strong> “Vibe Coding” 这个术语最近在技术圈非常流行，许多人认为它只是随意地向 AI 描述想法并生成代码。但 YC 合伙人 Tom 在过去一个月通过构建多个副业项目（Side Projects）的实验后发现，这不仅仅是一种新奇的玩法，更是一项可以通过练习显著精进的技能。这就好比一两年前的“提示词工程”（Prompt Engineering），当时人们每周都在发现新技巧。Tom 指出，<strong>最高效的 Vibe Coding 技巧，其实就是专业软件工程师一直以来遵循的最佳实践</strong>。即使有人质疑这不再是“凭感觉（Vibe）”而是传统的“软件工程”，但这正是问题的关键——我们的目标是利用这些工具获得最佳结果，而不是纠结于定义。</p><p><strong>YC 创业者的实战经验</strong> 在正式建议之前，视频展示了 YC Spring Batch 创业者们的真实心得，这些经验非常宝贵且具体：</p><ul><li><strong>多工具并用策略</strong>：一位创始人建议同时运行 <strong>Cursor</strong> 和 <strong>Windsurf</strong>。Cursor 速度较快，适合前端修改或全栈连接；而 Windsurf 思考时间更长，适合深层逻辑。利用一个工具“思考”的时间，可以在另一个工具中处理前端样式，甚至可以让两个工具针对同一需求生成不同版本，以此择优。</li><li><strong>自然语言编程</strong>：另一位创始人提出将 AI 视为一种新的编程语言。你不再是用代码语法编程，而是用自然语言编程。这意味着你需要像写代码一样，提供极高密度的上下文（Context）和详细信息，才能得到好结果。</li><li><strong>逆向开发（Test-First Approach）</strong>：一种非常稳健的方法是“逆向 Vibe Coding”。先手工编写测试用例（不使用 LLM），建立严格的护栏（Guardrails）。只有当测试用例准备好后，才让 LLM 自由生成代码。只要看到测试通过的“绿灯”，任务即算完成，无需微观管理代码细节。</li><li><strong>纯 LLM 规划先行</strong>：在进入代码编辑器之前，先在纯 LLM（如 ChatGPT 或 Claude 的网页版）中花费“不合理”多的时间来构建范围和架构。这能避免直接在代码库中胡乱生成行不通的方案。</li></ul><p><strong>工具选择指南</strong> 对于不同背景的开发者，工具的选择至关重要：</p><ul><li><strong>零基础新手</strong>：如果你从未写过代码，推荐使用 <strong>Replit</strong> 或 <strong>Lovable</strong>。这些工具提供直观的视觉界面，非常适合直接在代码中尝试新的 UI 想法。许多产品经理和设计师现在直接用代码实现想法，而不是画 Figma 原型，因为这样更快。但要注意，像 Lovable 这类工具在修改后端逻辑时可能会遇到瓶颈，有时修改一个按钮会导致后端逻辑发生奇怪的变化。</li><li><strong>有经验的开发者</strong>：即使你生疏了（Rusty），也建议直接跳过新手工具，使用 <strong>Windsurf</strong>、<strong>Cursor</strong> 或 <strong>Claude Code</strong>。这些工具提供了更强的控制力，适合处理复杂的全栈逻辑。</li></ul><h3 id="第二节：黄金工艺流–从规划到提交"><a href="#第二节：黄金工艺流–从规划到提交" class="headerlink" title="第二节：黄金工艺流–从规划到提交"></a>第二节：黄金工艺流–从规划到提交</h3><p><strong>“不写代码”的起手式</strong> 选定工具后的第一步，绝对<strong>不是</strong>直接开始写代码。Tom 强烈建议先与 LLM 合作编写一份<strong>综合计划（Comprehensive Plan）</strong>。</p><ul><li><strong>Markdown 计划书</strong>：将这份计划保存为项目文件夹中的 Markdown 文件。这份文件是你与 AI 的“契约”，在整个开发过程中要不断回看。</li><li><strong>迭代与修剪</strong>：在生成计划初稿后，要人工介入进行审查。删除你不喜欢的部分，明确标记某些功能为“不做”（Won’t do）或“过于复杂”。可以将一些稍后考虑的想法移入“Ideas for later”章节，明确告诉 LLM 这些当前在范围之外（Out of scope）。</li></ul><p><strong>分块执行与 Git 提交</strong> 一旦计划确立，执行过程必须是**逐节进行（Section by section）**的。</p><ul><li><strong>指令明确</strong>：明确告诉 AI，“现在我们只做第二部分”。</li><li><strong>验证与锁定</strong>：每完成一部分，立即运行测试并检查功能。确认无误后，进行 <strong>Git Commit</strong>。这是一个关键的“存档点”。</li><li><strong>更新计划</strong>：让 AI 回到 Markdown 计划文件中，将该部分标记为“已完成”。</li><li><strong>避免“一步登天”（One-shot）</strong>：目前的模型虽然强大，但还没好到能一次性生成整个复杂产品。试图让模型一次性完成所有工作通常会导致混乱。分步执行不仅稳健，还能让你在出错时有路可退。</li></ul><p><strong>版本控制的铁律</strong> 版本控制（Version Control）是 Vibe Coding 中最重要的安全网。</p><ul><li><strong>宗教般地使用 Git</strong>：尽管现在的 AI 编辑器都有内置的“Revert”（回滚）功能，但 Tom 坦言还不敢完全信任它们。他坚持使用 Git，确保在开始新功能前，代码库是干净的（Clean Git Slate）。</li><li><strong>重置的勇气（Git Reset Hard）</strong>：这是很多新手容易忽略的一点。如果 AI 在实现某个功能时“走火入魔”（Vision Quest），搞得一团糟，不要试图修补。直接执行 <code>git reset --hard</code>，回到上一个已知的良好状态。</li><li><strong>避免“代码淤泥”</strong>：如果你发现自己为了一个功能尝试了 4、5、6 个不同的 Prompt，代码库往往会堆积层层叠叠的错误逻辑（Layers of bad code&#x2F;craft）。正确的做法是：在脏代码中找到解决方案后，记录下来，然后 <strong>Reset</strong> 代码库，在干净的状态下一次性输入最终的解决方案。这样能保证代码的整洁，避免未知的副作用。</li></ul><h3 id="第三节：质量防线–测试策略与高级调试"><a href="#第三节：质量防线–测试策略与高级调试" class="headerlink" title="第三节：质量防线–测试策略与高级调试"></a>第三节：质量防线–测试策略与高级调试</h3><p><strong>高层次集成测试（High-Level Integration Tests）</strong> 测试在 Vibe Coding 中扮演着守门员的角色。LLM 擅长写测试，但往往倾向于写底层的单元测试（Unit Tests）。</p><ul><li><strong>模拟用户行为</strong>：Tom 建议指导 LLM 编写“超高层次”的测试。例如，模拟用户点击网站、浏览应用，确保端到端（End-to-End）的功能正常。</li><li><strong>防止回归（Catching Regressions）</strong>：LLM 有一个坏习惯，就是会在修改 A 处代码时，莫名其妙地改动 B 处无关的逻辑。拥有这套高层次测试套件，能让你在这种情况发生时立即察觉。一旦发现 AI 做了不必要的修改，立即 Reset 并重新开始。</li></ul><p><strong>调试（Debugging）的艺术</strong> 当 Bug 出现时，处理方式决定了效率。</p><ul><li><strong>复制粘贴错误信息</strong>：遇到 Bug，第一反应应该是直接将服务器日志或浏览器控制台的错误信息 Copy &amp; Paste 给 LLM。通常这不仅能定位问题，甚至不需要你解释发生了什么，AI 就能修复。Tom 预测未来这些工具将能自动读取日志或通过无头浏览器（Headless Browser）自行排查，无需人类充当“复制粘贴机器”。</li><li><strong>让 AI 先思考</strong>：对于复杂的 Bug，不要让 AI 马上写代码。要求它“列出 3 到 4 个可能的原因”，先进行推理。</li><li><strong>失败即重置（Reset on Failure）</strong>：这是反复强调的原则。如果 AI 尝试修复 Bug 失败了，不要让它在失败的代码基础上继续尝试。<strong>Reset</strong> 回去，重新开始。因为每一次失败的尝试都在代码中增加了无用的复杂度和垃圾代码（Crust&#x2F;Crap）。</li><li><strong>切换模型</strong>：如果你在一个模型上卡住了（比如 Claude Sonnet 3.7），试试 OpenAI 的模型或 Google 的 Gemini。不同模型在不同场景下有不同的“直觉”，往往能解决彼此解决不了的问题。</li><li><strong>干净重现</strong>：如果你在调试过程中最终找到了复杂的根源，建议 Reset 所有更改，然后在干净的代码库上给 AI 一个极其精确的指令来修复这个特定的 Bug，以保持代码库的纯净。</li></ul><h3 id="第四节：进阶技巧–上下文管理与复杂结构"><a href="#第四节：进阶技巧–上下文管理与复杂结构" class="headerlink" title="第四节：进阶技巧–上下文管理与复杂结构"></a>第四节：进阶技巧–上下文管理与复杂结构</h3><p><strong>指令文件与文档管理</strong> 为了让 AI 长期保持高效，你需要管理好它所拥有的上下文。</p><ul><li><p><strong>指令文件（Rules&#x2F;Instructions）</strong>：无论是 Cursor Rules, Windsurf Rules 还是 Claude 的 Markdown 文件，你应该编写一份核心指令集。有些创始人写了几百行指令，这能让 AI Agent 的效率成倍提升。这包括你的编码风格偏好、项目结构约定等。</p></li><li><p><strong>本地文档库</strong>：虽然 AI 可以联网，但直接读取在线文档的效果有时不稳定（Patchy）。Tom 建议将项目依赖的 API 文档全部下载下来，放在项目的一个子文件夹中。在指令中明确告诉 LLM：“在实现这个功能前，先去阅读那个文件夹里的文档。”这比依赖模型训练数据或联网搜索要准确得多。</p><blockquote><p>当然如果觉得下载 API 文档麻烦的情况下， 我觉得可以使用 Context 7 的 MCP 服务，也可以解决大部分信息准确性的问题。</p></blockquote></li></ul><p><strong>处理复杂功能与独立开发</strong> 当你需要开发一个超出常规复杂度的功能，或者你不敢信任 AI 直接在现有代码库中操作时：</p><ul><li><strong>独立项目（Standalone Project）策略</strong>：在一个完全空白的新代码库中开发这个功能。建立一个极简的参考实现（Reference Implementation），或者从 GitHub 下载一个现成的参考。</li><li><strong>移植逻辑</strong>：一旦在这个独立环境中跑通了，再指示 LLM 参考这个实现，将其“移植”到你的主代码库中。这种方法能有效隔离复杂性，避免搞坏主项目。</li></ul><p><strong>架构设计与技术栈选择</strong></p><ul><li><strong>模块化与 API 边界</strong>：适合 AI 的架构也是适合人类的架构。Tom 预测未来会更多地转向模块化或基于服务的架构。清晰的 API 边界让 AI 可以在不影响系统其他部分的情况下，自由修改内部实现。相比之下，巨型单体仓库（Monorepos）及其复杂的相互依赖关系，对 AI 和人类来说都是噩梦。</li><li><strong>选择“AI 友好”的技术栈</strong>：Tom 选择了 <strong>Ruby on Rails</strong>。尽管这是个 20 年的老框架，但 AI 写 Rails 代码的能力令人震惊。原因在于 Rails 有极其强大的“惯例优于配置”（Convention over Configuration）原则，且互联网上有海量的、结构高度一致的 Rails 代码作为训练数据。相比之下，像 Rust 或 Elixir 这样变体较多或数据较少的语言，AI 的表现可能较差。选择成熟、规范统一的框架是 Vibe Coding 的一个隐藏秘籍。</li></ul><h3 id="第五节：交互升级——多模态与持续实验"><a href="#第五节：交互升级——多模态与持续实验" class="headerlink" title="第五节：交互升级——多模态与持续实验"></a>第五节：交互升级——多模态与持续实验</h3><p><strong>利用多模态能力</strong></p><ul><li><strong>截图（Screenshots）</strong>：现在的编码 Agent 都支持图片输入。遇到 UI Bug，直接截图丢给它；想要模仿某个网站的设计，截图给它作为灵感。这比用语言描述 UI 问题要高效得多。</li><li><strong>语音编码（Voice Coding）</strong>：Tom 推荐使用 <strong>Aqua</strong>（一家 YC 公司产品）或其他语音工具。人类说话的速度（约 140 词&#x2F;分钟）是打字速度的两倍。而且现在的模型对语音转写的语法错误容忍度极高，即使转写不完美，AI 也能理解你的意图。Tom 甚至透露整个演讲稿都是用 Aqua 写成的。</li></ul><p><strong>非编码任务的自动化</strong> LLM 的用途不仅限于写代码：</p><ul><li><strong>DevOps 工程师</strong>：配置 DNS、设置 Heroku 托管、编写命令行脚本等繁琐任务，AI 可以以 10 倍的速度完成。</li><li><strong>设计师</strong>：Tom 使用 ChatGPT 生成网站图标（Favicon），然后让 Claude 写一个一次性脚本将图片调整为 6 种不同的尺寸格式。这些“一次性脚本”是 AI 极佳的用武之地。</li></ul><p><strong>持续实验与重构</strong></p><ul><li><strong>频繁重构（Refactor Frequently）</strong>：有了测试的保护，你可以大胆重构。甚至可以主动问 LLM：“代码库里哪些部分是重复的？哪些适合重构？”保持代码文件的短小精悍，对人类和 LLM 阅读都有好处。</li><li><strong>紧跟模型更新</strong>：这个领域的变化是以“周”为单位的。Gemini 目前在全库索引（Context Window）和规划方面表现出色；Claude Sonnet 3.7 在代码实现上似乎处于领先地位；GPT-4 系列也有其优势。建议在不同场景下尝试最新模型，不要死守一个工具。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Vibe Coding" scheme="https://maxweber36.github.io/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>📊 Google Gemini 3 多模态模型深度研究报告--- ChatGPT DeepResearch 深度分析</title>
    <link href="https://maxweber36.github.io/2025/11/20/Google-Gemini-3-%E5%A4%9A%E6%A8%A1%E6%80%81%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A-ChatGPT-DeepResearch-%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://maxweber36.github.io/2025/11/20/Google-Gemini-3-%E5%A4%9A%E6%A8%A1%E6%80%81%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A-ChatGPT-DeepResearch-%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2025-11-20T12:40:23.000Z</published>
    <updated>2025-12-03T09:31:31.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p><strong>说明</strong>：本报告基于 ChatGPT 的 DeepResearch 深度研究撰写</p><p>审核+校验：Weber</p></blockquote><hr><h2 id="I-执行摘要"><a href="#I-执行摘要" class="headerlink" title="I. 执行摘要"></a><strong>I. 执行摘要</strong></h2><h3 id="1-1-Gemini-3-的战略定位与核心技术概述"><a href="#1-1-Gemini-3-的战略定位与核心技术概述" class="headerlink" title="1.1 Gemini 3 的战略定位与核心技术概述"></a><strong>1.1 Gemini 3 的战略定位与核心技术概述</strong></h3><p>Google Gemini 3 的发布标志着大型语言模型（LLM）能力向原生多模态推理和高级智能体（Agentic）工作流迈出了重要一步。模型于 2025 年 11 月开始采取”静默部署”策略，在未进行传统高调宣传的情况下，将其性能逐步推向真实世界环境 ¹。这一策略旨在强调模型的实际表现而非营销炒作，是 Google 努力恢复开发者社区信心的重要举措 ¹。</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_04_42_03_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_04_42_03_PM"></p><p>Gemini 3 Pro 在多个核心基准上确立了新的技术标杆：</p><ul><li><strong>原生多模态领导者：</strong> 在评估集成理解和推理能力的 MMMU-Pro 基准上，Gemini 3 Pro 取得了 81.0% 的分数，领先竞争对手 GPT-5.1（76.0%）多达 5 个百分点 ²。</li><li><strong>Agentic 智能体核心：</strong> 在 Agentic 编码任务的 SWE-Bench Verified 基准上，Gemini 3 Pro 的单次尝试成功率达到 76.2%³。</li><li><strong>深层思维突破：</strong> 专为最困难推理任务设计的 Gemini 3 Deep Think 模式，在解决需要代码执行的新颖挑战（如 ARC-AGI-2）上，取得了 45.1% 的突破性得分 ⁴。</li></ul><h3 id="1-2-关键突破与市场地位"><a href="#1-2-关键突破与市场地位" class="headerlink" title="1.2 关键突破与市场地位"></a><strong>1.2 关键突破与市场地位</strong></h3><p>Deep Think 模式在复杂推理基准（如 Humanity’s Last Exam 达 41.0% ⁴）上的出色表现，表明该模型在泛化能力和抽象推理方面正向通用人工智能（AGI）的能力迈进。Gemini 3 的市场定位是面向需要处理复杂、多源数据的企业级 Agentic 平台的核心智能体。</p><h3 id="1-3-主要局限与风险提示"><a href="#1-3-主要局限与风险提示" class="headerlink" title="1.3 主要局限与风险提示"></a><strong>1.3 主要局限与风险提示</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_04_38_56_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_04_38_56_PM"></p><p>尽管取得了显著进步，Gemini 3 仍面临关键局限：</p><ul><li><strong>长上下文稳定性挑战：</strong> 尽管模型具备业界领先的 1M 令牌上下文窗口容量 ⁵，但在极端长上下文的点测试（MRCR v2, 1M pointwise）中，信息检索性能显著衰减至 26.3% ³。</li><li><strong>网络安全预警：</strong> 官方《前沿安全框架报告》（FSF）指出，Gemini 3 Pro 在网络安全领域已达到早期预警阈值 ⁶，这要求企业在部署其 Agentic 工作流时，必须采取严格的风险缓解措施。</li><li><strong>情感智能不足：</strong> 社区用户反馈，相比竞争对手，Gemini 在处理情感或生成自然对话时显得”最不自然” ⁷。</li></ul><hr><h2 id="II-Gemini-3-模型的重大突破与静默部署"><a href="#II-Gemini-3-模型的重大突破与静默部署" class="headerlink" title="II. Gemini 3 模型的重大突破与静默部署"></a><strong>II. Gemini 3 模型的重大突破与静默部署</strong></h2><h3 id="2-1-部署方式与初期用户反馈"><a href="#2-1-部署方式与初期用户反馈" class="headerlink" title="2.1 部署方式与初期用户反馈"></a><strong>2.1 部署方式与初期用户反馈</strong></h3><p>Gemini 3 的推出采用了与过去版本大为不同的”静默部署”策略。在技术界对 Gemini 生态系统长期存在的争议、隐私诉讼和图像生成失误保持高度关注的背景下 ¹，Google 于 2025 年 11 月在没有任何高调发布会或官方博客的情况下，静悄悄地开始在真实环境中部署 Gemini 3 ¹。</p><p>这种务实策略在开发者社区内获得了积极的反响。模型首先在 Canvas 移动端等环境中浮现，用户注意到工具开始产生比运行 Gemini 2.5 Pro 的桌面版本更高质量的结果 ¹。这种差异化性能对比很快在开发者论坛中传播，用户普遍的反馈是模型的能力得到了”戏剧性”的提升。一位 Reddit 用户总结了这种感受：”一切都是真实的，并有证据支持。这不是炒作。” ¹。</p><p>对于习惯了过度承诺和失望的开发者群体而言，Google 此次选择静默部署、强调实际性能而非市场宣传，被视为一种战略上的转变，意味着公司将重心从速度竞赛转向了可靠性与稳定性。对于正在寻求稳定、可信赖 AI 解决方案的企业用户来说，这种务实的态度有助于降低部署先进模型的风险。</p><h3 id="2-2-Deep-Think-模式：迈向通用智能（AGI）的信号"><a href="#2-2-Deep-Think-模式：迈向通用智能（AGI）的信号" class="headerlink" title="2.2 Deep Think 模式：迈向通用智能（AGI）的信号"></a><strong>2.2 Deep Think 模式：迈向通用智能（AGI）的信号</strong></h3><p>Gemini 3 Deep Think 模式代表了 Google 在提高模型推理复杂性方面所做的努力。Deep Think 旨在挑战并解决那些需要超越传统模式的抽象推理和规划能力的问题 ⁴。</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_07_04_31_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_07_04_31_PM"></p><p>该模式的关键性能体现在以下严苛的推理基准上：</p><ul><li><strong>Humanity’s Last Exam：</strong> 在不使用工具的情况下，Deep Think 取得了 41.0% 的得分 ⁴。</li><li><strong>GPQA Diamond：</strong> 在此基准上的得分为 93.8% ⁴。</li><li><strong>ARC-AGI-2：</strong> 在需要代码执行的 ARC Prize Verified 挑战中，取得了前所未有的 45.1% ⁴。</li></ul><p>Deep Think 在 ARC-AGI-2 上的高得分具有重大意义。ARC-AGI 评估的是模型解决<strong>未见过的</strong>、需要代码执行的抽象问题的能力。45.1% 的得分证实了 Deep Think 模式具备强大的泛化和抽象规划能力，意味着它可以将概念从训练数据泛化到新颖的领域，而不仅仅是记忆和复述。这种能力是判断模型是否具备 L3 或 L4 级别自主 AI Agent 能力的关键指标。</p><hr><h2 id="III-核心能力分析：多模态与超长上下文"><a href="#III-核心能力分析：多模态与超长上下文" class="headerlink" title="III. 核心能力分析：多模态与超长上下文"></a><strong>III. 核心能力分析：多模态与超长上下文</strong></h2><h3 id="3-1-原生多模态理解与推理的结构性优势"><a href="#3-1-原生多模态理解与推理的结构性优势" class="headerlink" title="3.1 原生多模态理解与推理的结构性优势"></a><strong>3.1 原生多模态理解与推理的结构性优势</strong></h3><p>Gemini 3 Pro 是一款原生的多模态模型，这意味着它能同时理解和推理不同的数据类型，如文本、图像和视频 ²。这种集成能力使其在多模态基准测试中占据结构性优势。</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_07_08_35_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_07_08_35_PM"></p><ul><li><strong>MMMU-Pro 领先性：</strong> MMMU-Pro 是衡量模型集成多模态理解和推理的关键基准。Gemini 3 Pro 在此基准上得分 81.0%，领先 GPT-5.1（76.0%）达 5 个百分点 ²。这表明 Gemini 3 在处理复杂的跨模态输入时，能更有效地进行深度推理。</li><li><strong>专业多模态应用：</strong> 模型的优势已延伸至专业领域的数据分析，而非仅限于消费级应用。例如，在复杂图表信息合成（CharXiv Reasoning）上，模型取得了 81.4% 的高分；在屏幕理解（ScreenSpot-Pro）上，得分也达到了 72.7% ³。这些表现意味着模型能够从复杂的、专业化的视觉数据（如金融图表、SaaS 界面截图）中准确提取并合成信息。</li><li><strong>多语言能力：</strong> Gemini 3 Pro 在多语言问答（MMMLU）基准上以 91.8% 的得分略微领先 GPT-5.1（91.0%），并在跨 100 种语言和文化的常识推理（Global PIQA）上取得 93.4% 的得分 ²。</li></ul><p>上述 CharXiv Reasoning 和 ScreenSpot-Pro 的高分表明，Gemini 3 的多模态能力已经从简单的图像描述升级为企业级的分析和自动化工具。其屏幕理解能力直接支撑了计算机使用智能体（computer use agents）的性能提升，这对推进 Agentic 工作流在 IT 运营、数据分析和企业自动化等场景中的落地至关重要 ⁸。</p><h3 id="3-2-长上下文处理能力评估：高容量与稳定性挑战并存"><a href="#3-2-长上下文处理能力评估：高容量与稳定性挑战并存" class="headerlink" title="3.2 长上下文处理能力评估：高容量与稳定性挑战并存"></a><strong>3.2 长上下文处理能力评估：高容量与稳定性挑战并存</strong></h3><p>Gemini 3 Pro 提供了业界领先的 1M 令牌上下文窗口，使得模型理论上能够一次性摄入和处理完整的代码库、企业级长文档或大量的历史对话记录 ⁵。这一容量被视为实现复杂、长周期 Agentic 任务的基础。</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_07_11_20_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_07_11_20_PM"></p><p>然而，对长上下文性能的评估揭示了容量与实际可靠性之间的差异：</p><ul><li><strong>1M 令牌容量：</strong> 模型在处理长上下文（如代码库或大型法律文档）时表现出超越前代模型的性能 ⁵。</li><li><strong>长上下文检索性能 (MRCR v2)：</strong> 在多段落内容检索（MRCR v2）基准上，模型在处理 128k 令牌的平均性能达到 77.0% ³。</li><li><strong>极端长上下文的衰减：</strong> 当测试上下文长度延伸至 1M 令牌，并采用极端点测试（pointwise，即”大海捞针”测试）时，Gemini 3 Pro 的信息检索准确率显著下降至 26.3% ³。</li></ul><p>这一数据显示了长上下文的“长尾效应”，即模型的整体容量虽然巨大，但在处理最长上下文时，对任意位置信息的精确检索稳定性仍然是瓶颈。这意味着企业在利用 1M 令牌窗口处理大型代码库或法律文档时，不能完全依赖模型在任意位置的精确检索，需要通过额外的分块、摘要和验证策略来缓解信息丢失的风险。</p><p><strong>关键数据表格 I：Gemini 3 Pro 核心能力基准 (官方数据)</strong></p><table><thead><tr><th><strong>基准名称</strong></th><th><strong>能力侧重</strong></th><th><strong>Gemini 3 Pro 评分</strong></th><th><strong>对比模型 (GPT-5.1)</strong></th><th><strong>数据来源</strong></th></tr></thead><tbody><tr><td>MMMU-Pro</td><td>多模态理解与推理</td><td>81.0%</td><td>76.0%</td><td>²</td></tr><tr><td>MMMLU</td><td>多语言问答</td><td>91.8%</td><td>91.0%</td><td>²</td></tr><tr><td>CharXiv Reasoning</td><td>复杂图表信息合成</td><td>81.4%</td><td>N&#x2F;A</td><td>³</td></tr><tr><td>SWE-Bench Verified</td><td>Agentic 编码（单次尝试）</td><td>76.2%</td><td>N&#x2F;A</td><td>³</td></tr><tr><td>MRCR v2 (128k average)</td><td>长上下文性能（平均）</td><td>77.0%</td><td>N&#x2F;A</td><td>³</td></tr><tr><td>MRCR v2 (1M pointwise)</td><td>极端长上下文性能（点测）</td><td>26.3%</td><td>N&#x2F;A</td><td>³</td></tr></tbody></table><hr><h2 id="IV-深度专题：AI-编码与智能体工作流的表现"><a href="#IV-深度专题：AI-编码与智能体工作流的表现" class="headerlink" title="IV. 深度专题：AI 编码与智能体工作流的表现"></a><strong>IV. 深度专题：AI 编码与智能体工作流的表现</strong></h2><p>Gemini 3 Pro 在 AI 编码领域的能力提升是其最受开发者关注的亮点之一。该模型不仅在传统代码生成上超越了前代版本 Gemini 2.5 Pro，更是在 Agentic 智能体工作流中展现出强大的规划和执行能力 ⁶。</p><h3 id="4-1-Agentic-Coding-能力的量化评估"><a href="#4-1-Agentic-Coding-能力的量化评估" class="headerlink" title="4.1 Agentic Coding 能力的量化评估"></a><strong>4.1 Agentic Coding 能力的量化评估</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_07_14_55_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_07_14_55_PM"></p><p>Gemini 3 Pro 的 Agentic 编码能力通过专业基准得以量化验证：</p><ul><li><strong>SWE-Bench 表现：</strong> 在解决现实世界代码库中的错误和问题所需的 Agentic 编码基准 SWE-Bench Verified 上，Gemini 3 Pro 获得了 76.2% 的得分 ³。</li><li><strong>Terminal-Bench 表现：</strong> Terminal-Bench 2.0 专门测试模型通过终端操作计算机和使用工具的能力。Gemini 3 Pro 在此基准上得分为 54.2% ⁸。这一分数直接反映了模型在自主执行开发任务中的效能。</li></ul><p>Gemini 3 Pro 已被定位为下一代 Agentic 编码模型的基础智能。它能够处理跨越整个代码库的复杂、长周期任务，并保持上下文以支持多文件重构、调试会话和功能实现 ⁸。这种能力使其成为企业进行遗留代码迁移和自动化软件测试的”力量倍增器” ⁵。</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_07_19_43_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_07_19_43_PM"></p><p>该模型已集成到 Google Antigravity（新的 Agentic 开发平台）、Gemini CLI、Android Studio，以及 Cursor、GitHub、JetBrains 等主流开发环境中 ⁸。例如，Google Antigravity 允许开发者充当架构师，与智能 Agent 协作，由 Agent 在编辑器、终端和浏览器中自主规划和执行复杂的软件任务 ⁶。</p><h3 id="4-2-实际开发体验：“意图领会”与零样本成功率"><a href="#4-2-实际开发体验：“意图领会”与零样本成功率" class="headerlink" title="4.2 实际开发体验：“意图领会”与零样本成功率"></a><strong>4.2 实际开发体验：“意图领会”与零样本成功率</strong></h3><p>来自开发者和行业专家的实际测试反馈，揭示了 Gemini 3 Pro 在现实编码任务中的高阶协作能力：</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_05_26_39_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_05_26_39_PM"></p><ul><li><strong>零样本突破：</strong> 有开发者反馈，他们能够通过单个提示（zero-shot prompt）生成一个功能完整的 3D 坦克游戏，这是他们在使用其他模型时从未实现过的 ⁹。这证明了其在复杂场景下强大的零样本解决能力。</li><li><strong>高阶协作能力与”意图领会”：</strong> 在与 GPT-5.1 和 Claude Sonnet 4.5 的真实编码任务对比中，Gemini 3 Pro 表现出一种”意图领会”的能力 ¹⁰。在创建网页版”拇指大战”游戏的任务中，作者最初只提到了”屏幕点击”控制，但 Gemini 3 Pro 的第一个版本<strong>主动添加了键盘控制</strong>选项 ¹⁰。</li><li><strong>设计优化：</strong> 在后续迭代中，模型不仅仅是执行指令，还对用户请求进行了优化和扩展。例如，当要求使游戏场看起来更真实时，Gemini 3 Pro 添加了 “CSS 视角倾斜”来增加深度 ¹⁰。当要求让攻击更具戏剧性时，模型实现了”整个摄像机在重击落地时晃动”的动画效果 ¹⁰。这种能力超越了简单的代码补全，使其成为真正的软件设计协作者。</li><li><strong>长程上下文保留：</strong> 在多轮复杂的 3D 编码迭代过程中，Gemini 3 Pro 始终保持强大的上下文记忆，从未要求作者重新开始或提醒先前的工作，有效提高了长周期项目中的开发效率 ¹⁰。</li></ul><p>这种能够预测用户未明确提出的需求、主动优化设计和保持长期任务上下文的能力，表明其 Agentic 模块能够结合上下文、目标平台和用户潜在意图进行高级推理和决策，显著提高开发效率并减少代码审查中的返工 ¹³。</p><p><strong>关键数据表格 II：Agentic Coding 性能对比</strong></p><table><thead><tr><th><strong>模型</strong></th><th><strong>SWE-Bench Verified (Agentic 编码)</strong></th><th><strong>Terminal-Bench 2.0 (工具使用)</strong></th><th><strong>实时编码任务反馈 (TechRadar 测试)</strong></th><th><strong>数据来源</strong></th></tr></thead><tbody><tr><td>Gemini 3 Pro</td><td>76.2%</td><td>54.2%</td><td>意图领会强，上下文保留优秀，主动优化用户请求</td><td>³</td></tr><tr><td>GPT-5.1</td><td>N&#x2F;A</td><td>N&#x2F;A</td><td>表现次于 Gemini 3 Pro，较少主动优化</td><td>¹⁰</td></tr><tr><td>Claude Sonnet 4.5</td><td>N&#x2F;A</td><td>N&#x2F;A</td><td>表现次于 Gemini 3 Pro，长期一致性可能更优</td><td>¹³</td></tr></tbody></table><hr><h2 id="V-顶尖主流模型竞争格局对比"><a href="#V-顶尖主流模型竞争格局对比" class="headerlink" title="V. 顶尖主流模型竞争格局对比"></a><strong>V. 顶尖主流模型竞争格局对比</strong></h2><p>2025 年的顶尖 LLM 竞争格局已经高度分化，模型不再是纯粹的通用文本生成器，而是根据其架构优势和目标市场（多模态、情感智能、长上下文、成本效益）进行差异化竞争。</p><h3 id="5-1-与-GPT-5-1-及-Claude-4-5-的直接竞争分析"><a href="#5-1-与-GPT-5-1-及-Claude-4-5-的直接竞争分析" class="headerlink" title="5.1 与 GPT-5.1 及 Claude 4.5 的直接竞争分析"></a><strong>5.1 与 GPT-5.1 及 Claude 4.5 的直接竞争分析</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_08_24_09_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_08_24_09_PM"></p><ul><li><strong>多模态与推理：</strong> Gemini 3 Pro 凭借其原生多模态架构，在 MMMU-Pro 上领先 GPT-5.1 5 个百分点 ²，确立了其在跨模态推理上的领导地位。</li><li><strong>长期记忆与一致性：</strong> Anthropic 的 Claude 4.5 采用了”Frontier”架构，其优势不在于原始参数量（Gemini 3 Pro 约为 1 万亿参数），而在于在长周期项目中的一致性。有企业用户测试反馈，在长达 6 周的合同审查任务中，Claude 4.5 能够始终记住细微的细节，如关于延迟付款的条款 ¹²。这表明 Claude 4.5 在处理持续、复杂的企业级任务时，可能在长期记忆的可靠性上优于 Gemini 3。</li><li><strong>商业模式：</strong> Gemini 3 Pro 为吸引更广泛的开发者和小型团队，提供了有限的免费层级，允许进行概念验证 ¹²。相比之下，Claude 4.5 主要面向企业用户，采用 $20&#x2F;月&#x2F;用户的付费订阅制 ¹²。</li></ul><h3 id="5-2-与-Grok-4-1-的差异化竞争：情感与事实的权衡"><a href="#5-2-与-Grok-4-1-的差异化竞争：情感与事实的权衡" class="headerlink" title="5.2 与 Grok 4.1 的差异化竞争：情感与事实的权衡"></a><strong>5.2 与 Grok 4.1 的差异化竞争：情感与事实的权衡</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_08_49_19_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_08_49_19_PM"></p><p>xAI 的 Grok 4.1 及其 Grok 4.1 Thinking 版本，采取了与 Gemini 截然不同的竞争路径，重点关注用户体验和情感交互。</p><ul><li><strong>情感智能的领导者：</strong> Grok 4.1 (Thinking) 在 LLM 评判的 EQ Bench（情感智能）基准上排名第一 ¹³。Grok 4.1 强调其在创造性、情感和协作互动中表现出色，对细微意图的感知更加敏锐，且具有连贯的个性 ¹³。</li><li><strong>文本竞技场表现：</strong> Grok 4.1 (Thinking) 在 LMArena 文本竞技场专家排行榜上以 1510 的得分位居榜首，成功超越了此前的领导者 Gemini 2.5 Pro ¹³。</li><li><strong>Gemini 3 的情商短板：</strong> 用户反馈表明，尽管 Gemini 在科学推理上表现出色，但在处理情感或需要自然、引人入胜的对话时，它显得”最不自然” ⁸。这反映了 Google 对安全和事实性的严格偏好，可能导致其在需要高度情商的场景中缺乏竞争力。</li></ul><p>Grok 4.1 在情感智能上的领先，标志着模型竞争已从纯粹的逻辑和硬指标，扩展到用户交互质量。对于面向客户服务的 AI 或创意写作 Agent 而言，Gemini 3 在情感自然度上的不足可能是一个明显的缺陷。</p><h3 id="5-3-国产模型-Kimi-K2-thinking-与-Minimax-M2-的定位"><a href="#5-3-国产模型-Kimi-K2-thinking-与-Minimax-M2-的定位" class="headerlink" title="5.3 国产模型 Kimi-K2-thinking 与 Minimax M2 的定位"></a><strong>5.3 国产模型 Kimi-K2-thinking 与 Minimax M2 的定位</strong></h3><p>在中国市场，以 Kimi-K2-thinking 和 Minimax M2 为代表的模型，凭借其在长上下文处理和成本效益方面的优势，形成了重要的竞争力量。</p><ul><li><strong>Kimi-K2-thinking：</strong> 该模型拥有 262.1K 令牌上下文窗口，并提供先进的推理和结构化数据生成能力 ¹⁶。虽然一些社区观点认为其性能（作为 INT4 量化模型）不可能显著超越 Claude 4.5 或 GPT-5，但在中文推理任务和长上下文处理上仍被认为是功能强大的模型，大致与 GLM 4.6 处于同等水平（Kimi K2 在推理上更强，GLM 4.6 在编码上更优） ¹⁷。</li><li><strong>Minimax M2：</strong> 这款模型具有 204.8K 令牌上下文，其主要竞争优势在于极高的成本效益（输入代币 $0.26&#x2F;M，输出代币 $1.02&#x2F;M） ¹⁶。尽管其参数量较小（10B&#x2F;230B），但在特定场景下仍被认为性能强劲，定位为经济高效的高性能选择 ¹⁷。</li></ul><p><strong>关键数据表格 III：顶尖主流模型竞争对比（2025 年 Q4 状态）</strong></p><table><thead><tr><th><strong>模型</strong></th><th><strong>核心架构&#x2F;规模</strong></th><th><strong>主要竞争优势</strong></th><th><strong>已知相对短板</strong></th><th><strong>关键指标&#x2F;排名</strong></th><th><strong>数据来源</strong></th></tr></thead><tbody><tr><td>Gemini 3 Pro</td><td>1 万亿参数，原生多模态</td><td>原生多模态集成，Agentic Coding，Deep Think 复杂推理</td><td>极端长上下文稳定性，情感智能不足</td><td>MMMU-Pro 81.0%，Terminal-Bench 54.2%</td><td>²</td></tr><tr><td>GPT-5.1</td><td>Frontier（未公开参数）</td><td>文本生成精度，上下文理解（持续优化）</td><td>多模态集成效果略逊于 Gemini 3</td><td>MMMU-Pro 76.0%，Creative Writing v3 排名第一（早期版）</td><td>²</td></tr><tr><td>Claude 4.5</td><td>Frontier 架构</td><td>长期记忆一致性，企业级支持</td><td>编码能力和零样本推理可能略逊于 Gemini 3 Pro</td><td>长期合同审查细节保持性强</td><td>¹³</td></tr><tr><td>Grok 4.1 (Thinking)</td><td>专注文本&#x2F;对话</td><td>情感智能 (EQ)，创造性写作，对话体验</td><td>科学&#x2F;逻辑硬指标对比未公开，多模态能力未知</td><td>EQ Bench 排名第一</td><td>¹³</td></tr><tr><td>Kimi-K2-thinking</td><td>INT4 量化</td><td>长上下文 (262.1K)，中文推理，性价比</td><td>参数规模限制，通用能力可能受限</td><td>上下文 262.1K 令牌</td><td>¹⁶</td></tr></tbody></table><hr><h2 id="VI-客观评估：局限性、用户体验及安全风险"><a href="#VI-客观评估：局限性、用户体验及安全风险" class="headerlink" title="VI. 客观评估：局限性、用户体验及安全风险"></a><strong>VI. 客观评估：局限性、用户体验及安全风险</strong></h2><p>对任何前沿 AI 模型的客观评估必须同时涵盖其性能优势和固有的局限性及安全风险。</p><h3 id="6-1-官方安全框架（FSF）下的风险与局限性解读"><a href="#6-1-官方安全框架（FSF）下的风险与局限性解读" class="headerlink" title="6.1 官方安全框架（FSF）下的风险与局限性解读"></a><strong>6.1 官方安全框架（FSF）下的风险与局限性解读</strong></h3><p>Google DeepMind 发布的《Gemini 3 Pro 前沿安全框架报告》主要聚焦于模型在四大前沿风险领域（CBRN、网络安全、ML R&amp;D 和有害操纵）的评估。总体而言，Gemini 3 Pro <strong>并未达到</strong>任何预先定义的”关键能力级别”（CCL），因此被判定为可接受部署 ⁷。</p><p>然而，报告揭示了以下关键的风险点和局限性：</p><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_19,_2025,_08_57_43_PM.png" alt="ChatGPT_Image_Nov_19,_2025,_08_57_43_PM"></p><ul><li><strong>网络安全风险达到早期预警阈值：</strong> Gemini 3 Pro 在网络安全领域达到了早期预警阈值（Uplift Level 1）⁷。尽管该模型在 13 个 v2 复杂网络挑战中均未能实现端到端解决（0&#x2F;13），但其在信息收集、漏洞分析等相对简单的任务上对低&#x2F;中级攻击者的能力加速作用已达到警戒线 ⁷。这一预警与 Gemini 3 Pro 卓越的 Agentic Coding 能力和工具使用能力（Terminal-Bench 54.2%）形成了风险叠加。模型擅长利用终端工具，如果企业将这种能力授权给 Agent 执行高权限任务，即使模型无法发起复杂的零日攻击，其在侦察和准备阶段的加速能力也可能被滥用。Google 声明将继续部署缓解措施 ⁷。</li><li><strong>CBRN（化学、生物、放射和核）风险：</strong> 模型能够提供准确的科学信息，特别是在 LAB-Bench 等基准上表现出统计学上的显著提升 ⁷。但由于其输出内容<strong>缺乏新颖性</strong>或<strong>足够完整详细的操作指令</strong>，因此并未显著增强低至中等资源威胁行为者的能力，未达到 CCL 或预警阈值 ⁷。</li><li><strong>有害操纵风险：</strong> 评估显示 Gemini 3 Pro 具备一定影响用户信念和行为的能力，但其功效与 Gemini 2.5 Pro 相比，没有统计学上的显著差异，因此未达到 CCL 或预警阈值 ⁷。</li></ul><p>值得注意的是，官方 FSF 报告主要关注前沿安全风险，并未包含关于模型偏见（Bias）和通用幻觉（Hallucination）的专门或详细评估结果 ⁷。</p><h3 id="6-2-模型精度与引用可靠性缺陷"><a href="#6-2-模型精度与引用可靠性缺陷" class="headerlink" title="6.2 模型精度与引用可靠性缺陷"></a><strong>6.2 模型精度与引用可靠性缺陷</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_02_19_23_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_02_19_23_PM"></p><p>在模型精度和可靠性方面，独立测试提供了混合的评估结果：</p><ul><li><strong>低幻觉率：</strong> 独立研究显示，Gemini 的幻觉率相对较低，测得约为 2.7% ¹⁹。</li><li><strong>引用可靠性缺陷：</strong> 尽管总体幻觉率低，但在需要精确、可验证的格式化输出时，模型表现出明显的局限性。在一项要求提供三篇带有正确 DOI 的同行评审论文的测试中，Gemini 模型给出了正确的论文名称，但其提供的三个 DOI 中有两个是错误的，且没有提供源链接 ²⁰。</li></ul><p>这种在格式化输出上的缺陷表明，模型的训练和输出验证机制在知识边界或需要精确调用外部标准时仍存在系统性错误。对于依赖模型进行严肃研究、学术引用或文档准备的专业用户而言，这是必须警惕的可靠性隐患。</p><h3 id="6-3-用户体验短板：情感智能的不足"><a href="#6-3-用户体验短板：情感智能的不足" class="headerlink" title="6.3 用户体验短板：情感智能的不足"></a><strong>6.3 用户体验短板：情感智能的不足</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_02_23_53_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_02_23_53_PM"></p><p>如前所述，用户社区对 Gemini 3 在交互体验上的短板有着一致的反馈。用户普遍认为，Gemini 擅长科学和逻辑，但在处理需要细腻情感理解和自然对话的场景时，表现”最不自然” ⁸。这种倾向可能源于 Google 对模型安全、客观和可靠性的严格训练，从而牺牲了在情感智能（EQ）和创造性表达上的优势。在 Grok 4.1 在 EQ Bench 上取得领先的竞争环境下，这种情感智能上的差距对 Gemini 3 拓展面向客户服务、心理咨询或高阶创意内容生成的应用场景构成了挑战。</p><p><strong>关键数据表格 IV：Gemini 3 Pro 安全框架 (FSF) 风险评估摘要</strong></p><table><thead><tr><th><strong>风险领域</strong></th><th><strong>关键能力级别 (CCL) 是否达到</strong></th><th><strong>早期预警阈值状态</strong></th><th><strong>主要发现&#x2F;局限性</strong></th><th><strong>数据来源</strong></th></tr></thead><tbody><tr><td><strong>网络安全</strong></td><td>否</td><td><strong>达到预警阈值</strong></td><td>对低&#x2F;中级攻击者有可量化的”能力提升”，需持续缓解</td><td>⁶</td></tr><tr><td><strong>CBRN 风险</strong></td><td>否</td><td>未达到</td><td>提供了准确的科学信息，但缺乏操作细节的新颖性</td><td>⁶</td></tr><tr><td><strong>有害操纵</strong></td><td>否</td><td>未达到</td><td>具备一定影响力，但与 2.5 Pro 相比无统计显著提升</td><td>⁶</td></tr><tr><td><strong>一般幻觉率</strong></td><td>N&#x2F;A</td><td>N&#x2F;A</td><td>独立测试显示幻觉率低 (2.7%)，但在引用 (DOI) 准确性上有缺陷</td><td>¹⁶</td></tr></tbody></table><hr><h2 id="VII-结论与战略展望"><a href="#VII-结论与战略展望" class="headerlink" title="VII. 结论与战略展望"></a><strong>VII. 结论与战略展望</strong></h2><h3 id="7-1-核心优势总结与市场定位"><a href="#7-1-核心优势总结与市场定位" class="headerlink" title="7.1 核心优势总结与市场定位"></a><strong>7.1 核心优势总结与市场定位</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_02_29_19_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_02_29_19_PM"></p><p>综合分析，Gemini 3 Pro 成功确立了其在两大关键领域的技术领导地位：<strong>原生多模态推理</strong>和<strong>Agentic Coding</strong>。其在 MMMU-Pro 上的领先地位以及 Deep Think 模式在 ARC-AGI-2 上的突破，证明了 Gemini 3 是一个为解决复杂、高难度任务而设计的企业级模型。它不再仅仅是一个聊天机器人，而是被架构为一个强大的基础智能体，能够利用其 1M 令牌上下文窗口，通过 Agentic 工作流完成跨越复杂数据集和整个代码库的长周期任务。</p><h3 id="7-2-未来挑战与发展方向"><a href="#7-2-未来挑战与发展方向" class="headerlink" title="7.2 未来挑战与发展方向"></a><strong>7.2 未来挑战与发展方向</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_02_30_00_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_02_30_00_PM"></p><p>Gemini 3 在实现其全部潜力方面仍面临结构性挑战：</p><ol><li><strong>稳定性挑战：</strong> 26.3% 的极端长上下文检索准确率表明，Google 必须解决在 1M 令牌容量下信息检索性能显著衰减的问题 ³。长上下文的商业价值在于其可靠性而非单纯的容量，因此模型需要进行结构优化，以确保信息在任何位置都能被可靠检索。</li><li><strong>情商差距：</strong> 在竞争对手 Grok 4.1 利用情感智能和引人入胜的对话体验获得市场优势时，Gemini 3 必须在不牺牲其严格安全标准的前提下，改进其在情感智能和对话自然度方面的表现 ⁸。</li><li><strong>安全部署的谨慎性：</strong> 网络安全预警 ⁷ 要求所有部署 Gemini 3 Agentic 工作流的企业必须采取严格的权限隔离和沙箱验证策略，以应对模型在漏洞分析和侦察任务中潜在的加速能力风险。</li></ol><h3 id="7-3-对行业竞争格局的影响"><a href="#7-3-对行业竞争格局的影响" class="headerlink" title="7.3 对行业竞争格局的影响"></a><strong>7.3 对行业竞争格局的影响</strong></h3><p><img src="/images/gemini-3-report/ChatGPT_Image_Nov_20,_2025,_02_50_29_PM.png" alt="ChatGPT_Image_Nov_20,_2025,_02_50_29_PM"></p><p>Gemini 3 的发布重新定义了大型模型在两个方面的竞争标准：</p><ul><li><strong>多模态基准的升级：</strong> Gemini 3 在原生多模态集成上的优势，迫使竞争对手（如 GPT-5.1）必须将多模态能力从后处理辅助功能升级为原生架构的核心能力。</li><li><strong>AI Agent 的专业化竞争：</strong> 模型的强大 Agentic Coding 能力以及 Antigravity 等平台的推出 ⁶，推动了行业从”通用 LLM”向”专业 Agentic 平台”的转型。未来的竞争将越来越依赖于模型作为核心智能体，在特定领域（如编码、金融分析、科学研究）的自主规划和执行能力。这加速了 AI 领域的专业化竞争格局的形成。</li></ul><h4 id="引用的著作"><a href="#引用的著作" class="headerlink" title="引用的著作"></a><strong>引用的著作</strong></h4><ol><li>Gemini 3 release imminent - here’s what to expect from Google’s latest release, 檢索日期：11 月 19, 2025， <a href="https://m.economictimes.com/news/international/us/gemini-3-release-imminent-heres-what-to-expect-from-googles-latest-release/articleshow/125413602.cms">https://m.economictimes.com/news/international/us/gemini-3-release-imminent-heres-what-to-expect-from-googles-latest-release/articleshow/125413602.cms</a></li><li>Google Gemini 3 Benchmarks - Vellum AI, 檢索日期：11 月 19, 2025， <a href="https://www.vellum.ai/blog/google-gemini-3-benchmarks">https://www.vellum.ai/blog/google-gemini-3-benchmarks</a></li><li>Gemini 3 Pro - Google DeepMind, 檢索日期：11 月 19, 2025， <a href="https://deepmind.google/models/gemini/pro/">https://deepmind.google/models/gemini/pro/</a></li><li>Gemini 3: Introducing the latest Gemini AI model from Google, 檢索日期：11 月 19, 2025， <a href="https://blog.google/products/gemini/gemini-3/">https://blog.google/products/gemini/gemini-3/</a></li><li>Gemini 3 is available for enterprise, 檢索日期：11 月 19, 2025， <a href="https://cloud.google.com/blog/products/ai-machine-learning/gemini-3-is-available-for-enterprise">https://cloud.google.com/blog/products/ai-machine-learning/gemini-3-is-available-for-enterprise</a></li><li>Gemini 3 Pro Frontier Safety Framework Report - Googleapis.com, 檢索日期：11 月 19, 2025， <a href="https://deepmind.google/models/fsf-reports/gemini-3-pro/">https://deepmind.google/models/fsf-reports/gemini-3-pro/</a></li><li>Grok 4.1 Benchmarks : r&#x2F;singularity - Reddit, 檢索日期：11 月 19, 2025， <a href="https://www.reddit.com/r/singularity/comments/1ozrjsf/grok_41_benchmarks/">https://www.reddit.com/r/singularity/comments/1ozrjsf/grok_41_benchmarks/</a></li><li>Gemini 3 for developers: New reasoning, agentic capabilities, 檢索日期：11 月 19, 2025， <a href="https://blog.google/technology/developers/gemini-3-developers/">https://blog.google/technology/developers/gemini-3-developers/</a></li><li>GPT-5.1 vs Gemini 3: Which AI Dominates 2025? - Skywork.ai, 檢索日期：11 月 19, 2025， <a href="https://skywork.ai/blog/ai-agent/gpt5-1-vs-gemini-3/">https://skywork.ai/blog/ai-agent/gpt5-1-vs-gemini-3/</a></li><li>I tested Gemini 3, ChatGPT 5.1, and Claude Sonnet 4.5 – and …, 檢索日期：11 月 19, 2025， <a href="https://www.techradar.com/ai-platforms-assistants/i-tested-gemini-3-chatgpt-5-1-and-claude-sonnet-4-5-and-gemini-crushed-it-in-a-real-coding-task">https://www.techradar.com/ai-platforms-assistants/i-tested-gemini-3-chatgpt-5-1-and-claude-sonnet-4-5-and-gemini-crushed-it-in-a-real-coding-task</a></li><li>Gemini 3: Google enables new agentic AI workflows for developers - Developer Tech News, 檢索日期：11 月 19, 2025， <a href="https://www.developer-tech.com/news/gemini-3-google-new-agentic-ai-workflows-for-developers/">https://www.developer-tech.com/news/gemini-3-google-new-agentic-ai-workflows-for-developers/</a></li><li>Elon Musk’s xAI edges past ChatGPT and Gemini with new Grok 4.1 update: here’s what you need to know, 檢索日期：11 月 19, 2025， <a href="https://www.livemint.com/technology/tech-news/elon-musks-xai-edges-past-chatgpt-and-gemini-with-new-grok-4-1-update-heres-what-you-need-to-know-11763458406576.html">https://www.livemint.com/technology/tech-news/elon-musks-xai-edges-past-chatgpt-and-gemini-with-new-grok-4-1-update-heres-what-you-need-to-know-11763458406576.html</a></li><li>Kimi K2 Thinking vs MiniMax M2 (Comparative Analysis) - Galaxy.ai Blog, 檢索日期：11 月 19, 2025， <a href="https://blog.galaxy.ai/compare/kimi-k2-thinking-vs-minimax-m2">https://blog.galaxy.ai/compare/kimi-k2-thinking-vs-minimax-m2</a></li><li>Gemini 3 vs Claude 4.5 2025 Enterprise AI Comparison - Skywork.ai, 檢索日期：11 月 19, 2025， <a href="https://skywork.ai/blog/llm/gemini-3-vs-claude-4-5-2025-enterprise-ai-comparison/">https://skywork.ai/blog/llm/gemini-3-vs-claude-4-5-2025-enterprise-ai-comparison/</a></li><li>Kimi K2 Thinking scores lower than Gemini 2.5 Flash on Livebench : r&#x2F;LocalLLaMA - Reddit, 檢索日期：11 月 19, 2025， <a href="https://www.reddit.com/r/LocalLLaMA/comments/1osglws/kimi_k2_thinking_scores_lower_than_gemini_25/">https://www.reddit.com/r/LocalLLaMA/comments/1osglws/kimi_k2_thinking_scores_lower_than_gemini_25/</a></li><li>Meta-Analysis of Gen AI Platforms: Uncovering Bias and Hallucination risks, 檢索日期：11 月 19, 2025， <a href="https://prabhakar-borah.medium.com/meta-analysis-of-gen-ai-platforms-uncovering-bias-and-hallucination-risks-599a6e2c2c12">https://prabhakar-borah.medium.com/meta-analysis-of-gen-ai-platforms-uncovering-bias-and-hallucination-risks-599a6e2c2c12</a></li><li>AI Showdown: Comparative Analysis of AI Models on Hallucination, Bias, and Accuracy - Software Testing and Development Company - Shift Asia, 檢索日期：11 月 19, 2025， <a href="https://shiftasia.com/column/comparative-analysis-of-ai-models-on-hallucination-bias-and-accuracy/">https://shiftasia.com/column/comparative-analysis-of-ai-models-on-hallucination-bias-and-accuracy/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>✨ AI 作图指南：轻松搞定公众号文章封面</title>
    <link href="https://maxweber36.github.io/2025/11/18/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B6%E4%BD%9C%E4%BC%98%E8%B4%A8%E7%9A%84%E6%B5%B7%E6%8A%A5%E6%88%96%E8%80%85%E5%B0%81%E9%9D%A2%E5%9B%BE_revised/"/>
    <id>https://maxweber36.github.io/2025/11/18/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B6%E4%BD%9C%E4%BC%98%E8%B4%A8%E7%9A%84%E6%B5%B7%E6%8A%A5%E6%88%96%E8%80%85%E5%B0%81%E9%9D%A2%E5%9B%BE_revised/</id>
    <published>2025-11-18T03:20:32.000Z</published>
    <updated>2025-11-18T04:04:57.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我一直有更新公众号的习惯。众所周知，一篇公众号文章不仅需要扎实的文字内容，一张吸引人的封面图也同样至关重要，甚至可以说是发布的硬性要求。</p><p>在过去很长一段时间里，我常常为封面图的选择而头疼。我曾尝试过两种方式：一是在日常浏览时有意识地收集好看的图片，作为素材库；二是直接用自己拍摄的生活照。但这两种方法都有一个共同的弊端——封面与文章内容往往毫不相关，无法有效传达文章的核心信息，导致吸引力大打折扣。</p><p>直到最近，我开始尝试使用 AI 工具来生成文章配图，结果发现效果出人意料地好。如今的文生图模型非常强大，不仅能生成各种风格的精美图片，在处理中文文字和排版方面也表现得相当出色。</p><h3 id="我的-AI-生图流程"><a href="#我的-AI-生图流程" class="headerlink" title="我的 AI 生图流程"></a>我的 AI 生图流程</h3><p>下面，我将总结并分享我利用 AI 工具为文章快速制作高质量封面的具体流程：</p><ol><li><p><strong>选择合适的文生图工具</strong><br>选择一个对中文优化较好的 AI 文生图网站。例如字节的「即梦」或夸克的「造点」，都是非常出色的工具，它们能够生成相当精准的中文文字。</p><blockquote><p><strong>补充说明：</strong></p><ul><li><strong>字节「即梦」</strong>：文生图需要消耗积分，但每天可以免费领取 60 积分，基本满足日常使用。</li><li><strong>夸克「造点」</strong>：使用阿里通义千问模型基本免费；使用 Midjourney 模型则需要消耗积分。需要注意的是，Midjourney 对中文文字的生成效果不佳，容易出现乱码。</li></ul></blockquote></li><li><p><strong>寻找灵感并获取 Prompt</strong><br>在文生图网站的“灵感库”或“创意广场”中，浏览并寻找符合你审美风格的图片。找到心仪的图片后，复制它所使用的 Prompt（提示词）。</p></li><li><p><strong>利用大语言模型优化 Prompt</strong><br>将复制的原始 Prompt 和你的文章核心内容一同发送给一个大语言模型（如 GPT、Kimi Chat、文心一言等）。</p></li><li><p><strong>下达修改指令</strong><br>要求 AI 深入理解你的文章主题，并基于此分析、修改原始 Prompt，使其生成的内容能更精准地贴合你的文章。</p></li><li><p><strong>生成并微调图片</strong><br>将 AI 修改并优化后的 Prompt 粘贴到文生图网站中，开始生成图片。如果对初次生成的结果不满意，可以返回上一步，让 AI 继续微调 Prompt，或在当前基础上多次生成，直至获得最理想的封面图。</p></li></ol><h3 id="关于水印的处理"><a href="#关于水印的处理" class="headerlink" title="关于水印的处理"></a>关于水印的处理</h3><p>到这里，一张为你量身定制的文章封面图就基本完成了。</p><p>不过，目前大多数免费的 AI 生图平台都会在图片上附加平台的水印。如果你希望得到一张干净的封面，最简单直接的方法就是对生成的图片进行适当的截图和裁剪。当然，你也可以在网上搜索并使用一些在线去水印工具来处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="工作流" scheme="https://maxweber36.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>🚫 Vibe Coding不是一条通向产品构建的捷径</title>
    <link href="https://maxweber36.github.io/2025/11/17/Vibe-Coding%E4%B8%8D%E6%98%AF%E4%B8%80%E6%9D%A1%E9%80%9A%E5%90%91%E4%BA%A7%E5%93%81%E6%9E%84%E5%BB%BA%E7%9A%84%E6%8D%B7%E5%BE%84/"/>
    <id>https://maxweber36.github.io/2025/11/17/Vibe-Coding%E4%B8%8D%E6%98%AF%E4%B8%80%E6%9D%A1%E9%80%9A%E5%90%91%E4%BA%A7%E5%93%81%E6%9E%84%E5%BB%BA%E7%9A%84%E6%8D%B7%E5%BE%84/</id>
    <published>2025-11-17T01:13:59.000Z</published>
    <updated>2025-12-03T09:18:27.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近我在微信公众号上读到了一篇文章<a href="https://mp.weixin.qq.com/s/7fjniJaRpHtoLpk6Q_6uag">《深度｜谷歌工程负责人警示：Vibe Coding 是资本炒热的危险幻觉，AI 只能完成 70% 的代码，未来开发将走向”三人编程”时代》</a>，文中表述的观点，与我最近的真实感受几乎一致。</p><p>我自己没有编程背景，最近用了很多 AI Coding 工具，从 Claude Code、Codex 到 TRAE，这些几乎是我每天都在用的工具。</p><p>我最近用这些工具自己开发了不少好玩的东西,从 Web 端到微信小程序,从 macOS 端到最近的 iOS 移动端。几乎所有的平台应用开发，我都用这些工具尝试了一遍。</p><p>从我自身的使用体验来看，我越来越认为现在所谓的”使用 AI 工具进行 Vibe Coding”这个概念听起来很酷，但具有强烈的误导性。</p><p><strong>特别是对于没有多少开发经验的人来说，以为使用这些工具就能快速磨平与真正开发者之间的差距。越是复杂的工程，Vibe Coding 埋下的坑就越大。</strong></p><p>我认为 Vibe Coding 最适合用来构建原型，但要真正做到可交付的产品，其实差距还是比较大的。</p><p>可交付的产品意味着：</p><ol><li><p>稳定的功能。当然接入 AI 可能会发生一些意外，但有工程方法可以让这种意外限制在一个可接受的范围内。</p></li><li><p>处理并发能力。可以处理适当的并发。</p></li><li><p>预期性能。产品可预期的表现和性能。</p></li><li><p>安全保障。产品具有基本的安全性保障（各种安全漏洞、API 密钥泄露、XSS 攻击层等等）。</p></li><li><p>问题定位。当产品出现 bug 的时候，能够快速定位到问题。</p></li></ol><p>真正的产品和产品原型，其实是两个完全不同类型的东西，中间的工作量可以说差了几乎一个数量级。</p><p><strong>如果说产品原型是 1 的话，那么要把它升级成产品，产品就是 10。</strong></p><p>构建产品不是创作艺术品的问题，它本质上还是一个工程问题。它需要考虑的地方还有很多，用代码实现产品功能，只是这冰山一角。</p><hr><p>另外，我想给所有非程序员同学推荐以上我正在使用的工具。</p><p>从我自己的使用体验来看：</p><p>被高估的：这些工具被强烈吹捧的是它们写代码的能力。<br>被低估的：真正被低估的是它们在非代码场景的运用，包括，写文章，管理文档，批量修改文件，批量修改数据，做数据分析，等等。</p><p>当然排除一些多媒体文件（视频，图片和音频）的剪辑，目前它们还做不到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Coding" scheme="https://maxweber36.github.io/tags/Coding/"/>
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="产品打磨" scheme="https://maxweber36.github.io/tags/%E4%BA%A7%E5%93%81%E6%89%93%E7%A3%A8/"/>
    
  </entry>
  
  <entry>
    <title>🛠️ TRAE Solo Coder 初体验</title>
    <link href="https://maxweber36.github.io/2025/11/14/Trae-solo-coder%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://maxweber36.github.io/2025/11/14/Trae-solo-coder%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2025-11-14T13:26:45.000Z</published>
    <updated>2025-12-03T09:31:20.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>前几天 TRAE 的 SOLO 正式版推出了。相比之前的 Beta 版本，这次更新新增了一个他们精细调校、专为复杂编码场景设计的 Code Agent——Solo Coder。</p><img src="/images/learn-agents/trae-solo-coder/image-20251114154444856.png" alt="image-20251114154444856" style="width: 60%; height: auto;" /><p>这两天我正好拿手头正在做的新产品来测试一些功能。</p><p>我这段时间做了一个移动端应用，叫做 Timer Whisper。这是一款语音驱动的计时器应用，主要通过自然语音的方式帮助人管理时间、提升做事效率。最大的特色就是语音控制。</p><p>这个应用涉及的模块还算不少，包括前端、后端、API 调用、数据库以及用户登录等。</p><p>我用 Solo Coder 主要完成了两件事情。</p><p>第一件事：统一语音识别中的静默终止时间与会话上限的配置。</p><p>目前这个应用的语音识别主要有两种方案：网络良好时优先调用远端的语音识别服务；网络较差时则调用本地语音识别。在开发早期，语音终止的时间阈值与语音识别会话上限由两个模块分别管理。因此我希望将这两个参数统一管理。此外，这两个参数此前都是以硬编码的方式写在各自模块里。</p><p>这件事比较简单，几乎一两次 prompt 交互就解决了。这次他们在 Solo Coder 中增加了一个 Plan 功能，类似于 Claude Code 的 Plan 模式。也就是在写代码实现之前，它会先写一个方案，大致包括目标、方案概述、修改点、验证方式以及其他备注。如果你觉得方案不合适，可以继续与它讨论，让它修改到满意为止，然后再开始编码。</p><hr><p>这次更新还新增了一个很实用的上下文压缩（compress）功能。在 Solo 模式下模型使用最大上下文，你可以随时查看当前上下文窗口的占比，避免上下文过长影响模型效果。</p><img src="/images/learn-agents/trae-solo-coder/image-20251114184304291.png" alt="image-20251114184304291" style="width: 60%; height: auto;" /><p>第二件事，我用它对产品进行 UI 改造。之前产品的 UI 是较为简洁的现代风格，我想把它改造成像素风格。</p><p><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.07.png" alt="Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.07" style="width: 45%; height: auto; margin-right: 8px;" /><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.31.png" alt="Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.31" style="width: 45%; height: auto;" /></p><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.27.png" alt="Simulator Screenshot - iPhone 16 Pro - 2025-11-14 at 11.11.27" style="width: 60%; height: auto;" /><p>这个需求相比上面的要复杂一些。我重新开启了对话窗口，直接提出要求：</p><p>「我想把这个应用的界面改成像素风，页面样式可以参考这些图片的风格。」因为 <strong>TRAE SOLO 支持多模态</strong>，我上传了一些样式图片（这些图片是我把应用的 UI 交给豆包，让它将 UI 样式转换成像素风后生成的）。<br><img src="/images/learn-agents/trae-solo-coder/UI 图风格转换 (2).png" alt="UI 图风格转换 (2)" style="width: 45%; height: auto; margin-right: 8px;" /><img src="/images/learn-agents/trae-solo-coder/UI 图风格转换 (1).png" alt="UI 图风格转换 (1)" style="width: 45%; height: auto;" /></p><img src="/images/learn-agents/trae-solo-coder/UI 图风格转换.png" alt="UI 图风格转换" style="width: 60%; height: auto;" /><p>豆包出的图还是挺美观的。当然我不指望 SOLO Coder 能完全还原这些图片，只要能把握精髓就可以了。</p><p>随后 SOLO Coder 开始写方案文档。</p><p>SOLO Coder 先启动了一个 Search Agent，调研 UI 的代码。它在调研过程中也表现出边思考边操作的特性，这就是常被讨论的 Interleaved Thinking（简单说，就是在“边想边做”的过程中，把每一步的思考带入后续操作，提高长程任务的规划与自我修正能力。可参考这篇介绍：<a href="https://mp.weixin.qq.com/s/az9OvwEKJ_vYifqlfw6rWA">Interleaved Thinking 解读</a>）。</p><p><img src="/images/learn-agents/trae-solo-coder/image-20251114191018753.png" alt="image-20251114191018753" style="width: 45%; height: auto; margin-right: 8px;" /><img src="/images/learn-agents/trae-solo-coder/image-20251114191844224.png" alt="image-20251114191844224" style="width: 45%; height: auto;" /></p><p>在查询时，它发现我的项目中同时存在 Web 页面的代码（之前尝试构建的官网页面）、Flutter 应用的代码，以及 iOS Widget（SwiftUI）的代码。因此它决定分批修改我的代码。考虑到我的 Web 页面只是测试用的官网，我重新提交了一个 prompt：</p><p>「第一批修改 Flutter 应用，第二批修改 iOS Widget，暂时不改 Web」。</p><p>随后 Solo Coder 根据最新要求，重新调整了界面改造计划。</p><img src="/images/learn-agents/trae-solo-coder/image-20251114193427365.png" alt="image-20251114193427365" style="width: 60%; height: auto;" /><img src="/images/learn-agents/trae-solo-coder/image-20251114193452523.png" alt="image-20251114193452523" style="width: 60%; height: auto;" /><p>确认修改方案没有问题后，我让它开始编码。</p><p>完成一轮代码修改后，它总结了本次改动，并给出了验证方法与后续建议。整体效率不错。另外，TRAE IDE 相比 Claude Code 或 Codex 这类 CLI 形态的 AI 编码编辑器更友好：你可以直观看到本次 AI 修改的代码，而无需自己使用 <code>git diff</code> 指令去对比。</p><p>在检查时我发现，页面上的主要图标和数字已经改为像素风。但也有几个问题：（1）底部导航栏的图标没有变化；（2）文字使用的是 GoogleFonts 库的像素字体，但不支持中文，因此中文部分没有变化，这部分需要后续寻找中文像素风的第三方字体库。</p><p>我提交了关于底部导航栏的修改需求，随后很快就完成了，一次性通过。</p><img src="/images/learn-agents/trae-solo-coder/image-20251114204510197.png" alt="image-20251114204510197" style="width: 60%; height: auto;" /><p>来看一下最终效果。Icon 图标是它通过 SVG 设计的，细节还不错，整体来说比较满意。</p><p><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.04.52.png" alt="Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.04.52" style="width: 31%; height: auto; margin-right: 8px;" /><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.05.01.png" alt="Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.05.01" style="width: 31%; height: auto; margin-right: 8px;" /><img src="/images/learn-agents/trae-solo-coder/Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.04.58.png" alt="Simulator Screenshot - iPhone 17 - 2025-11-14 at 21.04.58" style="width: 31%; height: auto;" /></p><p>最近 TRAE 的 SOLO 正式版正在限时免费，大家可以抓紧时间去体验一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="产品体验" scheme="https://maxweber36.github.io/categories/%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C/"/>
    
    
    <category term="Coding" scheme="https://maxweber36.github.io/tags/Coding/"/>
    
    <category term="产品学习" scheme="https://maxweber36.github.io/tags/%E4%BA%A7%E5%93%81%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="产品打磨" scheme="https://maxweber36.github.io/tags/%E4%BA%A7%E5%93%81%E6%89%93%E7%A3%A8/"/>
    
  </entry>
  
  <entry>
    <title>🛠️ 从一次 Flutter macOS Release 构建目录，看懂「产物」都在干什么</title>
    <link href="https://maxweber36.github.io/2025/11/03/flutter/"/>
    <id>https://maxweber36.github.io/2025/11/03/flutter/</id>
    <published>2025-11-03T03:39:03.000Z</published>
    <updated>2025-11-03T04:04:14.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="〇、一个真实案例：Timer-Whisper-的构建产物"><a href="#〇、一个真实案例：Timer-Whisper-的构建产物" class="headerlink" title="〇、一个真实案例：Timer Whisper 的构建产物"></a>〇、一个真实案例：Timer Whisper 的构建产物</h2><p>本文以我正在开发的 <strong>Timer Whisper</strong>（一款语音计时应用）为例进行说明。Timer Whisper 的核心特色是以<strong>语音为交互核心</strong>：用户通过语音指令控制计时器，比如「开始专注 25 分钟」「暂停计时」等。</p><p>基于这个特色功能，Timer Whisper 集成了以下原生能力，在构建产物中能看到这些核心插件：</p><ul><li><code>speech_to_text.framework</code> - 语音识别引擎，将用户语音转换为文字指令</li><li><code>record_macos.framework</code> - 音频录制，采集用户的语音输入</li><li><code>audio_session.framework</code> - 音频会话管理，确保语音识别和提示音不会冲突</li><li><code>just_audio.framework</code> - 音频播放，播放计时结束时的提示音</li><li><code>flutter_local_notifications.framework</code> - 系统通知，在计时结束时弹出提醒</li><li><code>isar_flutter_libs.framework</code> - 本地数据库，存储任务历史和用户配置</li><li><code>path_provider_foundation.framework</code> - 文件路径管理，为数据库提供存储位置</li><li><code>package_info_plus.framework</code> - 应用信息管理，显示版本号等</li></ul><h2 id="一、为什么要看-build-目录"><a href="#一、为什么要看-build-目录" class="headerlink" title="一、为什么要看 build 目录"></a>一、为什么要看 build 目录</h2><p>Flutter 开发里，我们最常敲的两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos          <span class="comment"># 调试用</span></span><br><span class="line">flutter build macos           <span class="comment"># 发布用</span></span><br></pre></td></tr></table></figure><p>第一条跑完，工程根目录下会蹦出一个 <code>build/</code> 文件夹；第二条跑完，里面会出现 <code>build/macos/Build/Products/Release/</code>。我第一次打开都会被”一堆 .framework 和 .dSYM”吓到——它们到底是干什么的？哪些能删、哪些要留？本文就借一次 Release 构建的产物，把 Flutter 在 macOS 上的”编译-打包-发布”链路拆清楚。</p><h2 id="二、Release-目录全景图（Timer-Whisper-实例）"><a href="#二、Release-目录全景图（Timer-Whisper-实例）" class="headerlink" title="二、Release 目录全景图（Timer Whisper 实例）"></a>二、Release 目录全景图（Timer Whisper 实例）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">build/macos/Build/Products/Release/</span><br><span class="line">├── .last_build_id</span><br><span class="line">├── App.framework</span><br><span class="line">├── App.framework.dSYM</span><br><span class="line">├── FlutterMacOS.framework</span><br><span class="line">├── FlutterMacOS.framework.dSYM</span><br><span class="line">├── Pods_Runner.framework</span><br><span class="line">├── audio_session.framework</span><br><span class="line">├── audio_session.framework.dSYM</span><br><span class="line">├── audio_session_privacy.bundle</span><br><span class="line">├── flutter_local_notifications.framework</span><br><span class="line">├── flutter_local_notifications.framework.dSYM</span><br><span class="line">├── isar_flutter_libs.framework</span><br><span class="line">├── isar_flutter_libs.framework.dSYM</span><br><span class="line">├── just_audio.framework</span><br><span class="line">├── just_audio.framework.dSYM</span><br><span class="line">├── package_info_plus.framework</span><br><span class="line">├── path_provider_foundation.framework</span><br><span class="line">├── record_macos.framework</span><br><span class="line">├── speech_to_text.framework</span><br><span class="line">├── timer_whisper.app</span><br><span class="line">├── timer_whisper.app.dSYM</span><br><span class="line">└── timer_whisper.swiftmodule</span><br></pre></td></tr></table></figure><p>下面按”谁生成的””干什么用””要不要留”三问，逐个拆解。</p><h2 id="三、产物角色大点名"><a href="#三、产物角色大点名" class="headerlink" title="三、产物角色大点名"></a>三、产物角色大点名</h2><table><thead><tr><th>产物</th><th>谁生成</th><th>干什么</th><th>要不要留</th><th>Timer Whisper 中的具体作用</th></tr></thead><tbody><tr><td><strong>.last_build_id</strong></td><td>Xcode 构建缓存</td><td>增量编译标记</td><td>可删</td><td>-</td></tr><tr><td><strong>App.framework</strong></td><td>Flutter Tool</td><td>Dart AOT 产物+入口</td><td>进最终 .app，不单独分发</td><td>包含 Timer Whisper 的所有 Dart 业务逻辑</td></tr><tr><td><strong>App.framework.dSYM</strong></td><td>Xcode</td><td>Dart 符号文件</td><td>必须留（崩溃还原）</td><td>用于分析 Dart 代码崩溃</td></tr><tr><td><strong>FlutterMacOS.framework</strong></td><td>Flutter 官方</td><td>引擎二进制</td><td>进最终 .app</td><td>Flutter 运行时的核心引擎</td></tr><tr><td><strong>FlutterMacOS.framework.dSYM</strong></td><td>Xcode</td><td>引擎符号</td><td>留</td><td>用于分析 Flutter 引擎崩溃</td></tr><tr><td><strong>Pods_Runner.framework</strong></td><td>CocoaPods</td><td>所有 pod 的合并产物</td><td>进 .app</td><td>包含所有插件的依赖管理</td></tr><tr><td><strong>audio_session.framework</strong></td><td>插件</td><td>音频会话管理</td><td>进 .app</td><td>确保 Timer Whisper 提示音不与其他应用冲突</td></tr><tr><td><strong>audio_session_privacy.bundle</strong></td><td>插件作者</td><td>Apple 隐私清单</td><td>进 .app</td><td>声明音频相关隐私权限</td></tr><tr><td><strong>flutter_local_notifications.framework</strong></td><td>插件</td><td>本地通知</td><td>进 .app</td><td>Timer Whisper 结束时弹出系统通知</td></tr><tr><td><strong>isar_flutter_libs.framework</strong></td><td>插件</td><td>本地数据库</td><td>进 .app</td><td>存储任务历史记录和配置</td></tr><tr><td><strong>just_audio.framework</strong></td><td>插件</td><td>音频播放</td><td>进 .app</td><td>播放白噪音和提示音，帮助专注</td></tr><tr><td><strong>package_info_plus.framework</strong></td><td>插件</td><td>应用信息</td><td>进 .app</td><td>获取应用版本号等信息</td></tr><tr><td><strong>path_provider_foundation.framework</strong></td><td>插件</td><td>路径提供</td><td>进 .app</td><td>管理数据库和配置文件路径</td></tr><tr><td><strong>record_macos.framework</strong></td><td>插件</td><td>音频录制</td><td>进 .app</td><td>录制用户语音指令</td></tr><tr><td><strong>speech_to_text.framework</strong></td><td>插件</td><td>语音识别</td><td>进 .app</td><td>将语音转换为文字指令</td></tr><tr><td><strong>timer_whisper.app</strong></td><td>Xcode 打包</td><td>最终可执行应用</td><td>对外分发就靠它</td><td>完整的 Timer Whisper 应用</td></tr><tr><td><strong>timer_whisper.app.dSYM</strong></td><td>Xcode</td><td>应用符号</td><td>留</td><td>崩溃分析必备</td></tr><tr><td><strong>timer_whisper.swiftmodule</strong></td><td>Swift 编译器</td><td>模块接口文档</td><td>调试用，可删</td><td>-</td></tr></tbody></table><h2 id="四、符号文件（-dSYM）到底做了什么"><a href="#四、符号文件（-dSYM）到底做了什么" class="headerlink" title="四、符号文件（.dSYM）到底做了什么"></a>四、符号文件（.dSYM）到底做了什么</h2><p>Release 为了体积和性能，会把函数名、文件名、行号等调试信息「剥离」出来，单独生成一个 .dSYM 目录。用户设备崩溃时，日志里通常只剩内存地址；有了同一次构建生成的 .dSYM，就能把地址翻译成可读的调用栈——这个过程叫「符号化」。</p><p>结论：只要你想事后分析崩溃，就必须把「应用 dSYM + 所有插件 dSYM」与对应版本的 .app 一起归档保存。</p><p>实操示例（校验 dSYM 与可执行文件是否匹配）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun dwarfdump --uuid timer_whisper.app.dSYM</span><br><span class="line">xcrun dwarfdump --uuid timer_whisper.app/Contents/MacOS/timer_whisper</span><br></pre></td></tr></table></figure><p>两条输出的 UUID 必须一致。</p><h2 id="五、隐私清单（privacy-bundle）是什么"><a href="#五、隐私清单（privacy-bundle）是什么" class="headerlink" title="五、隐私清单（privacy.bundle）是什么"></a>五、隐私清单（privacy.bundle）是什么</h2><p>从 macOS 14 &#x2F; iOS 17 开始，Apple 要求第三方 SDK 声明可能访问的敏感 API（例如 UserDefaults、文件时间戳等）。插件作者会在 bundle 里放一份 <code>PrivacyInfo.xcprivacy</code>，Xcode 打包时自动合并进最终应用。开发者一般不需要手动处理，但要知道它的存在，以便审核时回答隐私问卷。</p><h2 id="六、哪些文件需要进版本管理？"><a href="#六、哪些文件需要进版本管理？" class="headerlink" title="六、哪些文件需要进版本管理？"></a>六、哪些文件需要进版本管理？</h2><p><strong>不需要</strong>：</p><ul><li>整个 <code>build/</code> 目录（已经在 <code>.gitignore</code>）。</li></ul><p><strong>需要</strong>：</p><ul><li><code>macos/Runner/Release.entitlements</code>（声明沙箱权限）</li><li><code>macos/Podfile.lock</code>（保证团队 pod 版本一致）</li><li>每次发布时，把 <code>.app</code> 与 <code>.dSYM</code> 一起压缩归档，放到外部存储（Git LFS、网盘、崩溃平台皆可）。</li></ul><h2 id="七、常见疑问速答"><a href="#七、常见疑问速答" class="headerlink" title="七、常见疑问速答"></a>七、常见疑问速答</h2><ol><li><p><strong>为什么 Debug 目录没有 .dSYM？</strong><br>Debug 构建默认把符号留在本地，不额外生成 dSYM；只有 Release 才会剥离。</p></li><li><p><strong>可以只给用户 .app 吗？</strong><br>可以。.dSYM 不需要随应用分发，只留给自己做崩溃分析。</p></li><li><p><strong>插件的 dSYM 丢了怎么办？</strong><br>用相同 Flutter 版本、相同插件版本、相同电脑重新 <code>flutter build macos</code>，UUID 一致即可；否则无法符号化。</p></li><li><p><strong>如何验证符号文件是否匹配？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun dwarfdump --uuid timer_whisper.app.dSYM</span><br><span class="line">xcrun dwarfdump --uuid timer_whisper.app/Contents/MacOS/timer_whisper</span><br></pre></td></tr></table></figure><p>两条 UUID 必须一致。</p></li><li><p><strong>为什么 Timer Whisper 没有使用 flutter_tts 而是集成了这么多音频框架？</strong><br>Timer Whisper 采用<strong>语音识别 + 云端 TTS</strong>的方案：用户通过语音输入指令，系统通过云端 TTS 服务提供更自然、流畅的语音反馈。这种设计确保了跨平台一致性，同时云端 TTS 的语音质量更高，语音交互体验更好。</p></li><li><p><strong>Pods_Runner.framework 是什么？能删吗？</strong><br>它是 CocoaPods 把所有 pod 产物「聚合」出来的中间框架，Release 打包时会合并进 .app。不要手动删除。</p></li><li><p><strong>遇到 privacy 清单相关的构建报错怎么办？</strong><br>检查插件版本是否兼容当前 Xcode；若报「重复隐私声明」可升级插件或在 Podfile 里约束版本，避免旧版与新版冲突。</p></li><li><p><strong>Release 下资源缺失或提示音不播放？</strong><br>检查音频会话（audio_session）配置与资源打包路径，Debug 可播放但 Release 不行，常见原因是资源未正确加入 Runner 的 Copy Bundle Resources。</p></li></ol><h2 id="八、结语"><a href="#八、结语" class="headerlink" title="八、结语"></a>八、结语</h2><p>看懂一次 Release 构建的产物，就等于把 Flutter 在 macOS 端的「编译—链接—打包—发布」链路过了一遍。下次再见到 .dSYM、.framework、privacy.bundle，就不会再迷茫；该留的留，该扔的扔，发布与调试都能心里有底。祝你构建顺利，崩溃更少！</p><p>命令速查（macOS 构建相关）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调试运行</span></span><br><span class="line">flutter run -d macos</span><br><span class="line"></span><br><span class="line"><span class="comment"># Release 构建</span></span><br><span class="line">flutter build macos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验 dSYM 与可执行文件</span></span><br><span class="line">xcrun dwarfdump --uuid &lt;your.app&gt;.dSYM</span><br><span class="line">xcrun dwarfdump --uuid &lt;your.app&gt;/Contents/MacOS/&lt;binary_name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Flutter" scheme="https://maxweber36.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>📝 Timer-Whisper 产品开发日志 2025-10-23</title>
    <link href="https://maxweber36.github.io/2025/10/23/Timer-Whisper-%E4%BA%A7%E5%93%81%E6%97%A5%E5%BF%97/"/>
    <id>https://maxweber36.github.io/2025/10/23/Timer-Whisper-%E4%BA%A7%E5%93%81%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-23T01:03:10.000Z</published>
    <updated>2025-10-23T01:30:09.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>昨天，针对 Timer Whisper 在三个平台（macOS、iOS、Android）进行运行测试，已调试成功。<br><img src="/images/Timer-Whisper-%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-2025-10-23/screenshot-20251022-223212.png" alt="三端运行测试"></p><p>今天计划尝试构建 Android 和 macOS 的安装包，在我的华为手机和 macOS 上安装，并进行使用测试。预计这个过程可能需要约 90 分钟。</p><p>我的华为手机目前是非纯血版本的鸿蒙系统，不知道是否支持。🫤</p><p>下一步迭代计划是开发用户账号功能，目前考虑采用邮箱登录的方式，暂时不开放注册。将邀请周围的朋友，通过添加白名单的方式进行邮箱登录。</p><p>邮箱登录功能完成后，下一步是将数据库存储在云端，实现云端同步。这样可以保证在 macOS 和安卓手机端数据的一致性。</p><p>后续计划包括：</p><ul><li>搭建官网</li><li>研究推广方案（目前还没有具体思路）</li></ul><p>有些事情虽然暂时不知道怎么做，但还是必须要去做。无论是产品运营、开发还是设计。</p><blockquote><p><strong>我自己观察总结</strong>：在早期的很多事情上，我会因为不会而抗拒，心理上会有抵触。但我可以强迫自己去做，做了一段时间之后，其实会慢慢适应，然后开始擅长做这件事情，最后会喜欢做这件事情。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="产品日志" scheme="https://maxweber36.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>📱Timer-Whisper 的产品构想</title>
    <link href="https://maxweber36.github.io/2025/10/17/Time-Master-%E7%9A%84%E4%BA%A7%E5%93%81%E6%9E%84%E6%83%B3/"/>
    <id>https://maxweber36.github.io/2025/10/17/Time-Master-%E7%9A%84%E4%BA%A7%E5%93%81%E6%9E%84%E6%83%B3/</id>
    <published>2025-10-17T07:51:28.000Z</published>
    <updated>2025-10-17T09:07:26.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>产品构想的背景原因见：<a href="/2025/10/12/2025-10-12-%E4%BB%8E%E6%97%B6%E9%97%B4%E5%AF%8C%E4%BD%99%E5%88%B0%E5%88%86%E7%A7%92%E5%BF%85%E4%BA%89-%E6%96%B0%E6%89%8B%E7%88%B6%E6%AF%8D%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%BF%83%E5%BE%97/" title="⏰ 从时间富余到分秒必争：新手父母的时间管理心得">从时间富余到分秒必争：新手父母的时间管理心得</a></p><h2 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h2><p>我想做一个应用，它可以随时帮我记录时间的花费。最好能比较详细地统计每天的时间使用情况，比如吃饭花了多少时间，我其实也不太清楚。这个应用的核心功能，就是让我可以很方便地通过语音开始计时。</p><p>比如我说”我要做什么”，它就帮我创建一个任务并开始计时。等我做完了，说”结束”，它就帮我停止计时，并告诉我这次花了多少时间。</p><p>我真的很想做这样一个东西，主要是希望能完全通过语音来互动，并自动帮我生成一个时间账本，记录每天的时间花费。类似于财务账本记录金钱支出一样。</p><h2 id="产品描述"><a href="#产品描述" class="headerlink" title="产品描述"></a>产品描述</h2><p><strong>产品形态：</strong> 移动端应用</p><p><strong>核心差异化定位：</strong></p><p>Timer-Whisper 致力于打造极致的任务时间记录流畅体验，与传统时间管理应用的根本区别在于：<strong>实现真正的”无感记录”时间管理体验</strong>。</p><p>传统时间管理 APP 往往需要用户：</p><ul><li>手动填写任务名称、分类、标签等表单信息</li><li>在多个界面间切换操作</li><li>记住复杂的操作流程和功能入口</li></ul><p>而 Timer-Whisper 围绕<strong>语音交互为核心</strong>，用户可通过自然语音指令完成绝大多数操作：</p><ul><li><strong>任务创建</strong>：”开始写代码 30 分钟” → 自动创建任务并开始倒计时</li><li><strong>时间记录</strong>：”我已经完成了” → 自动结束计时并记录</li><li><strong>状态更新</strong>：”暂停一下” &#x2F; “继续” → 即时控制任务状态</li><li><strong>数据查询</strong>：”今天我花了多少时间在工作上？” → 语音播报统计结果</li></ul><p>这种设计最大程度减少了传统表单填写等手动输入场景，让时间记录变得像呼吸一样自然，用户可以专注于任务本身，而不是被记录工具打断思路。</p><p><strong>交互要求：</strong></p><ol><li><strong>极速唤起</strong>：一键进入语音交互模式，无需复杂导航</li><li><strong>语音优先</strong>：90%以上的功能操作可通过语音完成，彻底解放双手</li><li><strong>智能理解</strong>：支持自然语言指令，无需记忆特定命令格式</li></ol><p><strong>核心功能：</strong></p><ul><li>支持时间统计和分析功能，统计每天的时间开支，分析时间花费的分布情况</li><li>提供个性化的时间管理建议</li></ul><p><strong>界面设计：</strong></p><ul><li><p><strong>主界面</strong><br>一个大的语音按钮，用户点击按钮后，即开始向 APP 发送语音指令。</p><p>比如用户说”我要做什么，帮我开始设置 30 分钟倒计时”，然后就开始在后台启动一个计时器，并创建一个任务。</p><p>如果倒计时快结束时，APP 会主动提醒：是否需要继续延长时间？</p><p>如果用户提前完成，可以语音说”我已经完成”，或者直接点击结束按钮。然后后台会结束这个计时器，关闭任务，并在后台记录一共用了多少时间，以及开始和结束的时间。</p></li><li><p><strong>任务明细</strong><br>用户可以在任务明细中查看所有的历史任务，包括任务的名称、开始时间、结束时间、耗时等。</p></li><li><p><strong>时间统计</strong><br>用户可以在时间统计界面查看每天的时间开支，还可以查看时间开支的分布情况，比如在哪些时间段花费的时间最多。</p></li><li><p><strong>时间管理建议</strong><br>用户可以获得时间管理和事务管理的建议。</p></li></ul><h2 id="与传统时间管理-APP-的差异对比"><a href="#与传统时间管理-APP-的差异对比" class="headerlink" title="与传统时间管理 APP 的差异对比"></a>与传统时间管理 APP 的差异对比</h2><table><thead><tr><th>对比维度</th><th>传统时间管理 APP</th><th>Timer-Whisper</th></tr></thead><tbody><tr><td><strong>任务创建</strong></td><td>需要填写表单：任务名称、分类、标签、时长等多个字段</td><td>语音指令：”开始写代码 30 分钟” 一句话完成</td></tr><tr><td><strong>操作流程</strong></td><td>打开 APP → 找到新建按钮 → 填写表单 → 确认创建 → 手动开始</td><td>唤起 APP → 语音指令 → 自动开始</td></tr><tr><td><strong>任务结束</strong></td><td>手动点击停止 → 可能需要填写备注或分类</td><td>语音指令：”完成了” 或自动结束</td></tr><tr><td><strong>数据查询</strong></td><td>需要导航到统计页面 → 选择时间范围 → 查看图表</td><td>语音询问：”今天工作了多长时间？”</td></tr><tr><td><strong>学习成本</strong></td><td>需要熟悉界面布局、功能入口、操作流程</td><td>自然语言交互，几乎零学习成本</td></tr><tr><td><strong>使用场景</strong></td><td>适合坐在桌前、有空闲时间仔细操作</td><td>适合任何场景，包括做饭、运动、开车等解放双手的场景</td></tr></tbody></table><p><strong>核心优势总结：</strong></p><ul><li><strong>操作效率</strong>：从多步骤操作简化为一句话指令</li><li><strong>使用门槛</strong>：从需要学习界面到自然语言交互，几乎零学习成本</li><li><strong>适用场景</strong>：从特定场景扩展到全场景覆盖</li><li><strong>专注度保护</strong>：最小化对当前任务的干扰</li></ul><h2 id="设计时可以考虑的一些好的交互体验"><a href="#设计时可以考虑的一些好的交互体验" class="headerlink" title="设计时可以考虑的一些好的交互体验"></a>设计时可以考虑的一些好的交互体验</h2><h3 id="语音交互流畅性设计原则"><a href="#语音交互流畅性设计原则" class="headerlink" title="语音交互流畅性设计原则"></a>语音交互流畅性设计原则</h3><ol><li><strong>上下文记忆</strong>：记住用户的使用习惯，如常用任务名称、偏好时长等</li><li><strong>多轮对话</strong>：支持补充信息，如用户说”开始工作”后，系统询问”需要多长时间？”</li></ol><h3 id="核心交互体验"><a href="#核心交互体验" class="headerlink" title="核心交互体验"></a>核心交互体验</h3><ol><li><p><strong>反馈播报（TTS）</strong>：在计时开始时进行开始提醒，在倒计时快要结束时进行提醒，在结束时汇总耗时并进行提醒。</p></li><li><p><strong>快速唤起</strong>：</p><ul><li>主界面大语音按钮</li><li>系统通知快捷操作&#x2F;桌面小组件&#x2F;长按图标快捷动作（按平台可行性取舍至少实现一种）</li></ul></li><li><p><strong>智能预判</strong>：</p><ul><li>根据历史数据预测任务时长</li><li>主动提醒常规任务时间点</li><li>智能分类相似任务</li></ul></li></ol><h2 id="其他思考的补充"><a href="#其他思考的补充" class="headerlink" title="其他思考的补充"></a>其他思考的补充</h2><p><strong>1. 关于”倒计时”和”计时器（秒表）”的模式，推荐使用哪种模式？</strong></p><p>我个人推荐使用”倒计时”的模式。我觉得做任何事情，最好在事情开始之前，有一个自己心里预估的倒计时。这样会帮助自己在做事情的时候更加专注，从我个人的体验来看，效率也更高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="个人成长" scheme="https://maxweber36.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
    <category term="打磨产品" scheme="https://maxweber36.github.io/tags/%E6%89%93%E7%A3%A8%E4%BA%A7%E5%93%81/"/>
    
    <category term="Coding" scheme="https://maxweber36.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>🎯 Dart &amp; Flutter MCP 安装经验分享</title>
    <link href="https://maxweber36.github.io/2025/10/15/Dart-Flutter-MCP-%E5%AE%89%E8%A3%85%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://maxweber36.github.io/2025/10/15/Dart-Flutter-MCP-%E5%AE%89%E8%A3%85%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2025-10-15T03:10:11.000Z</published>
    <updated>2025-10-15T03:55:35.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近在使用 Flutter 开发移动端应用，因此需要安装 Dart &amp; Flutter MCP 来辅助进行代码分析与问题排查。</p><p>按照 <a href="https://dart.dev/tools/mcp-server#use-your-mcp-client">Google 官方文档</a>进行安装时，出现以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✖ MCP ERROR (dart): Error: spawn dart ENOENT</span><br><span class="line">✖ Error during discovery for server &#x27;dart&#x27;: spawn dart ENOENT</span><br></pre></td></tr></table></figure><p>该错误通常表示系统无法找到 <code>dart</code> 可执行文件，常见原因是 Dart SDK 未安装或环境变量未正确配置。</p><h2 id="定位-Dart-SDK-的安装路径"><a href="#定位-Dart-SDK-的安装路径" class="headerlink" title="定位 Dart SDK 的安装路径"></a>定位 Dart SDK 的安装路径</h2><p>我在排查后确认 Dart 已安装（我是在 IDE（TRAE）中安装 Flutter 时附带安装了 Dart SDK），但环境变量未配置好。通过查找 Dart SDK 安装目录，定位到 <code>dart-sdk</code> 的路径。</p><blockquote><p>如果 Dart 是随 Flutter 安装的（Flutter 内置 Dart SDK），路径在 Flutter 安装目录的 <code>bin/cache/dart-sdk</code> 下，格式为：<code>/Users/你的用户名/flutter/bin/cache/dart-sdk</code>（其中 <code>/Users/你的用户名/flutter</code> 是你的 Flutter 安装路径）。</p></blockquote><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>我使用的是 macOS ，因此需要将 Dart SDK 的路径加入 <code>PATH</code> 环境变量。编辑 <code>~/.zshrc</code>（如果没有该文件，可新建），并添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/flutter/bin/cache/dart-sdk/bin&quot;</span></span><br></pre></td></tr></table></figure><p>保存文件并执行 <code>source ~/.zshrc</code> 使配置生效。（如未使用默认路径，请替换为实际安装路径。）</p><h2 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h2><p>在新的终端窗口执行 <code>dart --version</code>。如果能正常显示 Dart 版本信息，则说明配置成功。</p><h2 id="重新配置-Flutter-Dart-MCP"><a href="#重新配置-Flutter-Dart-MCP" class="headerlink" title="重新配置 Flutter &amp; Dart MCP"></a>重新配置 Flutter &amp; Dart MCP</h2><p>我使用 MCP Router 统一管理所有 MCP 服务器的配置，因此重新添加了 Dart 服务器的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dart&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dart&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;mcp-server&quot;</span><span class="punctuation">,</span> <span class="string">&quot;--force-roots-fallback&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>重新在 MCP Router 开启 Flutter &amp; Dart MCP 后，问题得到解决。</p><p><img src="/images/dart-flutter-mcp/dart-mcp.gif" alt="Dart &amp; Flutter MCP 安装演示"></p><h2 id="其他参考文档"><a href="#其他参考文档" class="headerlink" title="其他参考文档"></a>其他参考文档</h2><ol><li>Dart &amp; Flutter MCP 官方文档. Dart.dev. <a href="https://dart.dev/tools/mcp-server">https://dart.dev/tools/mcp-server</a> （访问日期：2025-10-15）</li><li>Dart &amp; Flutter MCP Git 文档. GitHub - dart-lang&#x2F;ai. <a href="https://github.com/dart-lang/ai/tree/main/pkgs/dart_mcp_server">https://github.com/dart-lang/ai/tree/main/pkgs/dart_mcp_server</a> （访问日期：2025-10-15）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Coding" scheme="https://maxweber36.github.io/tags/Coding/"/>
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>⚡ 工具太多反而成负担：我的效率优化反思</title>
    <link href="https://maxweber36.github.io/2025/10/14/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%8D%E6%80%9D%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://maxweber36.github.io/2025/10/14/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%8D%E6%80%9D%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2025-10-14T05:23:12.000Z</published>
    <updated>2025-10-15T06:09:02.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我觉得自己现在用的工具实在太多了。一会儿是 iFlow，一会儿又是 CodeX，然后还有 Claude Code，还有 GLM4.6，还有 Gemini……天哪，我到底有多少个工具？</p><p>我发现自己有一个很大的怪癖：在使用某个工具时，虽然有些工具只是偶尔用，但只要我觉得这个工具有问题，就会花很多时间去调试，非得把问题解决了才安心。为此，我可能会花一两个小时，甚至更多时间，只为解决一个工具的问题。</p><p>但等我把工具调试得差不多了，结果一个月可能用不到十次。这真的让我觉得很搞笑。我的大部分时间都花在调工具、磨刀上了，真正”砍柴”的时间很少。就像削铅笔花了很多时间，画画却没画多少，写字也没写多少。我的时间就是这样被用掉的。</p><p>说实话，我觉得还是应该选一两个主力工具，不要总是来回切换。这样效率真的很低，时间全都浪费了。</p><p>现在 Claude Code 这个工具，我打算后面就不再用了，也不打算续费了。毕竟续费要两百多块钱，还是有点贵，所以我打算集中精力用其他工具。</p><p><strong>我的工具选择策略：</strong></p><ul><li>主要工具：GLM4.6 + Trae（作为主力工具）</li><li>辅助工具：Gemini（作为补充）</li><li>淘汰工具：Claude Code（不再续费）<br>对我来说，收益和成本相比，确实不划算。</li></ul><p>稍微总结一下，我现在的主力工具是 Trae 和 GLM4.6，Gemini 作为辅助工具，其他的暂时就不考虑了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="生活记录" scheme="https://maxweber36.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
    <category term="效率优化" scheme="https://maxweber36.github.io/tags/%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>⏰ 从时间富余到分秒必争：新手父母的时间管理心得</title>
    <link href="https://maxweber36.github.io/2025/10/12/2025-10-12-%E4%BB%8E%E6%97%B6%E9%97%B4%E5%AF%8C%E4%BD%99%E5%88%B0%E5%88%86%E7%A7%92%E5%BF%85%E4%BA%89-%E6%96%B0%E6%89%8B%E7%88%B6%E6%AF%8D%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%BF%83%E5%BE%97/"/>
    <id>https://maxweber36.github.io/2025/10/12/2025-10-12-%E4%BB%8E%E6%97%B6%E9%97%B4%E5%AF%8C%E4%BD%99%E5%88%B0%E5%88%86%E7%A7%92%E5%BF%85%E4%BA%89-%E6%96%B0%E6%89%8B%E7%88%B6%E6%AF%8D%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%BF%83%E5%BE%97/</id>
    <published>2025-10-12T05:43:48.000Z</published>
    <updated>2025-10-15T08:56:21.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/%E6%96%B0%E6%89%8B%E7%88%B6%E6%AF%8D/album_temp_1760509609.PNG" alt="来自于《名画都是猫》"></p><center><i>图片来源：《名画都是猫》</i></center><p>现在做事情确实需要更有计划。因为有了小朋友之后，做事不仅仅是处理自己的事情，还要照顾孩子，这中间要花很多时间。而这些时间是比较刚性的，没办法减少。</p><p>在这样的情况下，如何还能做自己想做的事情，就需要有很好的规划。我觉得，现在面临的一个最大挑战就是：<strong>时间管理的困难</strong>。如何在照顾好小朋友的同时，还能做好自己的事情。</p><p>所以在时间利用上，我需要更有意识：</p><ul><li>现在正在做什么</li><li>这段时间花在哪里</li></ul><p>这样才能把握住时间，不让它无意义地流失掉。</p><p>我以前在这方面可能太放纵、太舒服了，因为自己时间太多了。时间多的时候，对时间的开销和利用没有那么强的意识，可能时间就糊里糊涂地用掉了，就像花钱一样，糊里糊涂地就把钱花掉了。</p><p>只有当开始记录时间的时候，我才知道我的时间到底花在了哪里，我才知道我到底在做什么。</p><blockquote><p>有意识地去使用自己的时间，要把时间投入到有意义、有价值的事情上，这一切从记录时间开支开始。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="生活记录" scheme="https://maxweber36.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
    <category term="个人成长" scheme="https://maxweber36.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
    <category term="育儿" scheme="https://maxweber36.github.io/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>📍 LocateIt - AI 图片地理定位工具</title>
    <link href="https://maxweber36.github.io/2025/10/04/LocateIt-AI-%E5%9B%BE%E7%89%87%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/"/>
    <id>https://maxweber36.github.io/2025/10/04/LocateIt-AI-%E5%9B%BE%E7%89%87%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/</id>
    <published>2025-10-04T04:00:00.000Z</published>
    <updated>2025-10-05T00:44:08.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="📋-产品概述"><a href="#📋-产品概述" class="headerlink" title="📋 产品概述"></a>📋 产品概述</h2><p><strong>乐可寻 Locate-It</strong> 是一款基于人工智能的地点识别服务，通过分析图片内容来推测可能的地理位置。我们采用多模态 AI 模型结合网络检索技术，对图片中的视觉信息进行智能分析和推理，为用户提供地点参考信息。</p><h2 id="🎯-核心功能"><a href="#🎯-核心功能" class="headerlink" title="🎯 核心功能"></a>🎯 核心功能</h2><h3 id="🌍-AI-视觉分析与推理"><a href="#🌍-AI-视觉分析与推理" class="headerlink" title="🌍 AI 视觉分析与推理"></a>🌍 AI 视觉分析与推理</h3><ul><li><strong>多模态 AI 识别</strong>：采用 BigModel GLM-4.5V 模型，分析图片中的视觉特征</li><li><strong>智能推理机制</strong>：基于图像内容、建筑风格、自然景观等线索进行地点推测</li><li><strong>GPS 数据优先</strong>：当图片包含 EXIF GPS 数据时，优先使用精确坐标信息</li><li><strong>概率性结果</strong>：提供基于 AI 分析的地点建议，而非绝对准确的位置信息</li></ul><h3 id="🎨-虚拟场景分析与原型探索"><a href="#🎨-虚拟场景分析与原型探索" class="headerlink" title="🎨 虚拟场景分析与原型探索"></a>🎨 虚拟场景分析与原型探索</h3><ul><li><strong>作品场景识别</strong>：识别动漫、游戏、影视剧中的虚拟场景</li><li><strong>现实原型推测</strong>：基于视觉特征推测可能的现实取景地或灵感来源</li><li><strong>创意推理</strong>：通过 AI 推理分析虚拟场景与现实地点的关联性</li><li><strong>外部验证</strong>：利用网络搜索验证和补充识别结果</li></ul><h3 id="🗺️-地点信息展示与地图可视化"><a href="#🗺️-地点信息展示与地图可视化" class="headerlink" title="🗺️ 地点信息展示与地图可视化"></a>🗺️ 地点信息展示与地图可视化</h3><ul><li><strong>交互式地图</strong>：在百度地图上展示推测的地点位置</li><li><strong>坐标参考</strong>：提供地理坐标作为位置参考信息</li><li><strong>地址解析</strong>：将坐标转换为可读的地址描述</li><li><strong>可视化展示</strong>：直观的地图界面帮助用户理解位置信息</li></ul><h3 id="🔍-智能搜索与信息补充"><a href="#🔍-智能搜索与信息补充" class="headerlink" title="🔍 智能搜索与信息补充"></a>🔍 智能搜索与信息补充</h3><ul><li><strong>网络检索</strong>：集成 Tavily API 搜索相关地点信息</li><li><strong>信息提取</strong>：从搜索结果中提取有用的位置描述和背景资料</li><li><strong>交叉验证</strong>：通过多源信息提升识别结果的可信度</li><li><strong>背景补充</strong>：提供地点的相关背景信息和文化介绍</li></ul><h2 id="🎨-产品特色"><a href="#🎨-产品特色" class="headerlink" title="🎨 产品特色"></a>🎨 产品特色</h2><h3 id="🤖-双模式分析能力"><a href="#🤖-双模式分析能力" class="headerlink" title="🤖 双模式分析能力"></a>🤖 双模式分析能力</h3><ul><li><strong>现实场景分析</strong>：分析真实照片中的地点线索，推测可能位置</li><li><strong>虚拟场景探索</strong>：处理二次元和影视内容，探索现实原型可能性</li></ul><h3 id="📱-友好的用户体验"><a href="#📱-友好的用户体验" class="headerlink" title="📱 友好的用户体验"></a>📱 友好的用户体验</h3><ul><li><strong>简洁操作</strong>：拖拽或点击上传图片，即可开始分析</li><li><strong>多格式支持</strong>：支持 JPG、PNG、WebP、HEIC 等常见格式</li><li><strong>实时进度</strong>：展示分析进度，让用户了解处理状态</li><li><strong>结果展示</strong>：清晰的分析结果展示，包括推理过程说明</li></ul><h3 id="🎯-智能化推理流程"><a href="#🎯-智能化推理流程" class="headerlink" title="🎯 智能化推理流程"></a>🎯 智能化推理流程</h3><ul><li><strong>多层次分析</strong>：从整体景观到具体细节的逐步分析</li><li><strong>线索整合</strong>：综合视觉线索、GPS 数据、网络信息进行推理</li><li><strong>概率评估</strong>：为识别结果提供置信度参考</li><li><strong>透明化过程</strong>：展示 AI 的推理逻辑和判断依据</li></ul><h2 id="🎯-主要使用场景"><a href="#🎯-主要使用场景" class="headerlink" title="🎯 主要使用场景"></a>🎯 主要使用场景</h2><h3 id="🎮-动漫游戏文化探索"><a href="#🎮-动漫游戏文化探索" class="headerlink" title="🎮 动漫游戏文化探索"></a>🎮 动漫游戏文化探索</h3><p><strong>场景</strong>：看到动漫游戏中的美丽场景，想了解现实中的可能取景地<br><strong>价值</strong>：发现虚拟作品与现实世界的连接，为「圣地巡礼」提供参考</p><h3 id="🎬-影视拍摄地探寻"><a href="#🎬-影视拍摄地探寻" class="headerlink" title="🎬 影视拍摄地探寻"></a>🎬 影视拍摄地探寻</h3><p><strong>场景</strong>：观看影视剧时对某个场景产生兴趣，想了解拍摄地信息<br><strong>价值</strong>：探索影视作品背后的真实地点，满足观众的好奇心</p><h3 id="🏞️-摄影创作参考"><a href="#🏞️-摄影创作参考" class="headerlink" title="🏞️ 摄影创作参考"></a>🏞️ 摄影创作参考</h3><p><strong>场景</strong>：摄影师寻找拍摄地点参考，分析优秀作品的地理位置<br><strong>价值</strong>：为摄影创作提供地点灵感，帮助发现新的拍摄角度</p><h2 id="🔬-技术原理说明"><a href="#🔬-技术原理说明" class="headerlink" title="🔬 技术原理说明"></a>🔬 技术原理说明</h2><h3 id="🧠-AI-分析机制"><a href="#🧠-AI-分析机制" class="headerlink" title="🧠 AI 分析机制"></a>🧠 AI 分析机制</h3><p>我们的系统采用多模态 AI 模型，通过以下步骤进行分析：</p><ol><li><strong>视觉特征提取</strong>：识别图片中的建筑、自然景观、人文特征</li><li><strong>风格判断</strong>：分析建筑风格、植被特征、地形地貌等线索</li><li><strong>地理位置推理</strong>：基于视觉线索和知识库推测可能的地区</li><li><strong>网络验证</strong>：通过搜索相关信息验证和补充推测结果</li></ol><h3 id="📊-结果可信度"><a href="#📊-结果可信度" class="headerlink" title="📊 结果可信度"></a>📊 结果可信度</h3><ul><li><strong>GPS 数据</strong>：当图片包含精确 GPS 信息时，准确性最高</li><li><strong>AI 推测</strong>：基于视觉分析的地点推测，提供参考性建议</li><li><strong>网络验证</strong>：通过多源信息交叉验证提升结果可信度</li></ul><h2 id="📈-产品特点"><a href="#📈-产品特点" class="headerlink" title="📈 产品特点"></a>📈 产品特点</h2><ol><li><strong>AI 驱动</strong>：基于最新多模态 AI 技术的智能分析</li><li><strong>推理导向</strong>：通过逻辑推理提供地点建议，而非简单匹配</li><li><strong>虚实结合</strong>：同时支持现实场景和虚拟场景分析</li><li><strong>用户体验</strong>：简洁直观的操作流程</li><li><strong>信息丰富</strong>：提供地点背景信息和文化介绍</li><li><strong>持续学习</strong>：AI 模型不断优化，提升分析能力</li></ol><h2 id="🚀-使用建议"><a href="#🚀-使用建议" class="headerlink" title="🚀 使用建议"></a>🚀 使用建议</h2><ul><li><strong>提供线索</strong>：在分析时提供地区范围或作品名称等线索可提升效果</li><li><strong>理解概率性</strong>：AI 分析结果仅供参考，实际地点可能存在差异</li><li><strong>多角度验证</strong>：重要用途建议结合其他方式确认地点信息</li><li><strong>探索发现</strong>：将产品视为探索工具，发现图片背后的有趣故事</li></ul><hr><p><strong>乐可寻 Locate-It</strong> — 让 AI 帮您探索图片背后的地理故事 🌍🔍</p><h2 id="项目链接"><a href="#项目链接" class="headerlink" title="项目链接"></a>项目链接</h2><ul><li><a href="https://www.locateit.pics/">官方网站</a></li><li><a href="https://app.locateit.pics/">在线体验</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="project" scheme="https://maxweber36.github.io/categories/project/"/>
    
    
    <category term="AI应用" scheme="https://maxweber36.github.io/tags/AI%E5%BA%94%E7%94%A8/"/>
    
    <category term="地理定位" scheme="https://maxweber36.github.io/tags/%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D/"/>
    
    <category term="图像识别" scheme="https://maxweber36.github.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
    <category term="Web应用" scheme="https://maxweber36.github.io/tags/Web%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>👓 定制自己的透镜</title>
    <link href="https://maxweber36.github.io/2025/09/25/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%80%8F%E9%95%9C/"/>
    <id>https://maxweber36.github.io/2025/09/25/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%80%8F%E9%95%9C/</id>
    <published>2025-09-24T17:03:15.000Z</published>
    <updated>2025-09-24T17:35:56.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>        <div id="aplayer-yCMwCVRx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-yCMwCVRx"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Catching The Dawn",              author: "weber",              url: "/music/Catching-The-Dawn.m4a",              pic: "/music-cover/with-music.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>我越听重轻的播客，越听越觉得他的阐述能力非常牛逼的。其实，他的很多观点或者说视角并不是我觉得是最牛的，虽然他的观点确实帮我开拓了很多视角，让我有种豁然开朗的感觉。但在听他论述的时候，他在表达的很多观点，其实我在其他书里也见过类似的表达，可是看那些书的时候，并没有像听他给我讲的时候，那种让我眼前一亮、仿佛被点醒的感觉。</p><p>我觉得重轻最厉害的地方，就是他的阐释能力或者叫做叙事的能力。当他把同样的事情重新讲一遍的时候，你会从中感受到那个故事就明显带上了他自己独特的烙印。虽然内容本质上还是原来的事，但经过他的讲述，就完全变成了另一回事，让人感觉很不一样。这就是一种讲故事的能力。</p><p>我在想，怎么才能培养自己这种讲故事的能力，把一个平平无奇的故事讲得特别生动、特别有趣。我觉得重轻有这种能力，还有之前我看过一个台湾综艺节目，是大 S 和小 S 一起主持的。我觉得大 S 也有这种能力，有时候听她讲一些事情，或者大 S、小 S 一起聊日常，本来是很无聊的事，但被她们一说就变得非常有趣。</p><p>我觉得，尤其是在现在这个社会，叙事能力真的非常重要。它能够改变一个人对一件事情的看法。就好像在你和这个世界之间加了一个透镜，这个透镜会折射、会改变光线进入你眼睛的路径。虽然我们现在看世界时，已经透过了很多了透镜，但大多数人用的都是标准化的透镜，也就是最最主流的叙事。</p><p>而当我在听重轻讲一个故事、或者阐述一件事的时候，我会发现他的透镜是他手工定制的，带有他自己独特的曲面和材质。光线经过他的透镜时，所穿过的路径和我日常用的、工厂里生产的标准透镜完全不一样。这种差异会给我带来另外一种看世界的样子。</p><p><strong>推荐最近重轻的一期播客，很震撼。</strong><br><a href="https://www.gcores.com/radios/183775"><img src="/images/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%80%8F%E9%95%9C/fcsm.JPG" alt="蜂巢生命封面"> 原型 vol.3 ｜ 蜂巢生命</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="个人成长" scheme="https://maxweber36.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
    <category term="关于写作" scheme="https://maxweber36.github.io/tags/%E5%85%B3%E4%BA%8E%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>🏗️ 新手避免“代码混乱”的核心策略：重视项目结构规划与初始化流程</title>
    <link href="https://maxweber36.github.io/2025/09/20/%E6%96%B0%E6%89%8B%E9%81%BF%E5%85%8D-%E2%80%9C%E4%BB%A3%E7%A0%81%E6%B7%B7%E4%B9%B1%E2%80%9D-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5%EF%BC%9A%E9%87%8D%E8%A7%86%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    <id>https://maxweber36.github.io/2025/09/20/%E6%96%B0%E6%89%8B%E9%81%BF%E5%85%8D-%E2%80%9C%E4%BB%A3%E7%A0%81%E6%B7%B7%E4%B9%B1%E2%80%9D-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5%EF%BC%9A%E9%87%8D%E8%A7%86%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</id>
    <published>2025-09-20T09:31:56.000Z</published>
    <updated>2025-09-20T09:47:27.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>对于没有系统编程背景的人，刚开始使用 AI Coding 工具构建产品时，最容易犯的错误就是一上来就提需求，让 AI 直接编写代码。这样做在编写简单脚本或小页面时问题不大，但一旦是稍微复杂的产品，随着功能增长、代码量和模块增多，代码就会变得越来越混乱。尤其是交给 AI 来写，更容易堆出“屎山代码”。如果前期不做好项目结构的规划与规范，它就容易“随意发挥”（freestyle）；写得越快，后期的可维护性往往越差。</p><h2 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h2><p>刚进入产品构建或初次接触一个新项目的同学，最重要的学习环节：先了解并熟悉项目结构。</p><h2 id="为什么要在开发一个项目之前，最好初始化？"><a href="#为什么要在开发一个项目之前，最好初始化？" class="headerlink" title="为什么要在开发一个项目之前，最好初始化？"></a>为什么要在开发一个项目之前，最好初始化？</h2><p>一言以蔽之：建立项目结构的规范，保障项目代码的可维护性。</p><h2 id="什么是初始化？"><a href="#什么是初始化？" class="headerlink" title="什么是初始化？"></a>什么是初始化？</h2><p>“初始化”指的是在正式写业务代码前完成的“打地基”步骤。以前端项目（Next.js + Tailwind CSS + shadcn&#x2F;ui + Framer Motion）为例，通常包括：</p><ul><li>生成基础项目结构（通过脚手架工具，如 create-next-app）</li><li>配置 TypeScript、ESLint、Prettier（保证代码规范与可维护性）</li><li>安装并配置 Tailwind CSS（原子化样式）</li><li>安装并初始化 shadcn&#x2F;ui（高质量 UI 组件）</li><li>安装 Framer Motion（动画库），并处理其与 Next.js App Router 及客户端组件的配合</li><li>建立 Git 版本管理并配置忽略文件</li><li>准备环境变量文件</li></ul><h2 id="一个完全不懂的规划自己项目结构的人，应该如何初始化自己的项目结构？"><a href="#一个完全不懂的规划自己项目结构的人，应该如何初始化自己的项目结构？" class="headerlink" title="一个完全不懂的规划自己项目结构的人，应该如何初始化自己的项目结构？"></a>一个完全不懂的规划自己项目结构的人，应该如何初始化自己的项目结构？</h2><p>对于刚入坑 AI Coding 的人来说，最容易忽略的一点就是项目结构的规划。如果不知道如何规划项目结构，一般有两种方法：</p><ol><li><p>根据你项目所使用的技术栈，通过标准化的命令行指令，来初始化自己的项目，搭建一个初步的项目结构。</p><ul><li>例如 Next.js 项目，可以通过执行以下命令进行初始化：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest my-app \</span><br><span class="line">  --typescript \</span><br><span class="line">  --eslint \</span><br><span class="line">  --tailwind \</span><br><span class="line">  --src-dir \</span><br><span class="line">  --app \</span><br><span class="line">  --import-alias &quot;@/*&quot;</span><br><span class="line"></span><br><span class="line">  解释一下这段命令行指令</span><br><span class="line"></span><br><span class="line">* npx create-next-app@latest：使用 npx 临时执行最新版本的 create-next-app（不会全局安装）。</span><br><span class="line">* my-app：要创建的项目目录名（会在当前目录创建名为 my-app 的文件夹）。</span><br><span class="line">* --typescript：初始化为 TypeScript 项目（生成 tsconfig、.tsx 文件等）。</span><br><span class="line">* --eslint：自动配置 ESLint（基本 lint 规则）。</span><br><span class="line">* --tailwind：自动添加并配置 Tailwind CSS。</span><br><span class="line">* --src-dir：把源码放在 src/ 目录下（而不是根目录）。</span><br><span class="line">* --app：启用 Next.js 的 app Router（app/ 目录结构）。</span><br><span class="line">* --import-alias &quot;@/*&quot;：在 tsconfig.json/jsconfig.json 中生成路径别名 &quot;@/*&quot; -&gt; &quot;src/*&quot;（方便 import &quot;@/components/...&quot;）。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在开始撰写代码之前，先让 AI 根据项目的技术栈和需求，进行初步的项目规划。</p></li></ol><blockquote><p>友情提示：对于此前没有进行过项目规划的朋友，在完成项目结构的初步搭建后，最好让 AI 生成一份《项目结构说明书》，对结构规范加以说明。该文件可以放到项目根目录的 docs&#x2F; 文件夹下（例如：docs&#x2F;structure-guide.md）。</p></blockquote><h2 id="清晰和明确的项目结构到底有什么好处？"><a href="#清晰和明确的项目结构到底有什么好处？" class="headerlink" title="清晰和明确的项目结构到底有什么好处？"></a>清晰和明确的项目结构到底有什么好处？</h2><p>一个产品的项目结构，并不是简单的“文件夹分类”，它是一套<strong>约定好的“信息组织规则”</strong>，无论是人还是工具（AI、编译器、打包工具），都需要通过这套规则理解代码逻辑、依赖关系和功能边界。</p><p>一个清晰和明确的项目结构会有哪些重要的好处？</p><ol><li><p>降低“认知成本”。能够让人和 AI 快速了解到这个项目框架，并快速定位到代码。它就像是一个好的目录文件一样。</p></li><li><p>帮助理解上下文。AI 生成好的代码的前提是“理解上下文”——如果项目结构清晰明确，比如你只需要提示 AI 在<code>src/components/Button</code> 下写一个按钮组件，它就能够精准生成并自动关联依赖；如果结构随意，AI 无法判断“新代码该放在哪，该引用哪个文件夹的文件”，这样就很容易生成重复代码（比如重复写同一个工具函数）或者路径引入错误，然后就累计出“屎山代码”。</p></li><li><p>让 AI 生成的代码规范，保障可维护。AI 本身不具有“长期项目规划能力”，若没有结构约束，AI 会为了快速实现功能，就信马由缰，“哪里有空就往哪里写”，在后续迭代的时候，新增代码会不断叠加在混乱的基础上，最终导致代码完全无法维护。</p></li><li><p>适配工具链，确保项目能够正常运行、打包和部署。现代项目开发需要依赖大量工具（比如前端的 Webpack&#x2F;Vite、后端的 Node.js&#x2F;Java 框架、版本控制 Git），这些工具的正确运行都需要遵循“约定的项目结构”，才能工作。</p><ol><li>例如前端 Vite 默认会从 <code>src/main.js</code> 入口文件开始打包，若你随意把入口文件改名为 “start.js” 且不配置路径，打包时会直接报错；</li><li>后端 Spring Boot 框架默认扫描 <code>com.example.demo.controller</code> 路径下的接口，若你随意更改 <code>controller</code> 文件夹名，接口会无法被识别，导致服务启动后无法访问。</li></ol><p>若结构不规范，不仅工具会失效，甚至可能出现 “本地能运行、部署到服务器就报错” 的问题（比如路径引用错误），排查起来极其耗时。</p></li></ol><p>总之，项目结构的核心价值是 “<strong>建立规则，降低混乱</strong>”—— 对人而言，它是 “导航地图”；对 AI 而言，它是 “约束框架”；对工具而言，它是 “工作协议”。而 “不随意更改结构或文件名”，本质是维护这套规则的有效性，避免项目从 “可控的工程” 沦为 “不可维护的代码垃圾”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Coding" scheme="https://maxweber36.github.io/tags/Coding/"/>
    
    <category term="技术总结" scheme="https://maxweber36.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>💭 一场辩论想到:不要害怕暴露短板,持续去创造才是真正重要的事情</title>
    <link href="https://maxweber36.github.io/2025/09/11/%E4%B8%80%E5%9C%BA%E8%BE%A9%E8%AE%BA%E6%83%B3%E5%88%B0-%E4%B8%8D%E8%A6%81%E5%AE%B3%E6%80%95%E6%9A%B4%E9%9C%B2%E7%9F%AD%E6%9D%BF-%E6%8C%81%E7%BB%AD%E5%8E%BB%E5%88%9B%E9%80%A0%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>https://maxweber36.github.io/2025/09/11/%E4%B8%80%E5%9C%BA%E8%BE%A9%E8%AE%BA%E6%83%B3%E5%88%B0-%E4%B8%8D%E8%A6%81%E5%AE%B3%E6%80%95%E6%9A%B4%E9%9C%B2%E7%9F%AD%E6%9D%BF-%E6%8C%81%E7%BB%AD%E5%8E%BB%E5%88%9B%E9%80%A0%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%83%85/</id>
    <published>2025-09-11T14:48:54.000Z</published>
    <updated>2025-09-11T15:34:31.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>前期提要：咸鱼和陈锴杰，我都不认识。之前听了一小段咸鱼和橘子的直播辩论。其实这种公开辩论的形式，是非常好的。当然，这是一场建设者和批判者的辩论。在这场辩论赛中，批判者永远是对的。所以在这场辩论赛的开始，作为批判者的咸鱼，在身份上占据了先天的优势。</p></blockquote><p>好了，我说一下我的整体感受。</p><p>我听了一下咸鱼和产品叫 macaron 的创始人陈锴杰之间的辩论。我自己没有用过 macaron 这个产品，但大致能想象出来， 这个产品现在用起来应该是非常难用的。不过，他们团队好像还是拿到了一些投资机构的钱。</p><p>怎么说呢？在听他们辩论的时候，我明显觉得 macaron 的创始人确实有很多想法，而且这些想法听起来也非常宏大。以现在的情况来看，要实现这些功能，中间的挑战还是非常多的。而且能感觉到，以他们目前的团队想要实现这些功能，能力上还是很困难的。他的一些设想是比较合理的，但都还比较粗线条。但是要落地，又是另外一回事了。</p><p>不过对于 macaron 的创始人，我还是想多多鼓励他，只要是亲身做过产品的，就知道做产品，真的是一件很难的事情。不管他现在做出来的东西是什么样，但他一直在做。我觉得只要一直在做，就有改进的可能性，这点很重要。</p><p>至于咸鱼，他更多是一种批判的角度，去指出这个产品其实被吹得太厉害了，浮于表面大于本质，甚至说它就是“一坨屎”。他想给大家指出这个产品的很多问题。你说，他在辩论中指出的那些问题是不是对不对？我觉得肯定是对的。但是，你说他这样做有没有意义？可能有，但我觉得意义不是那么大。</p><p>我想，谁会去关注咸鱼关于抨击这些产品的事情呢？像咸鱼这样的人，整天抨击别人，说这个不好、那个也不好，可能主要就是吸引一些纯粹吃瓜的人。但这些吃瓜的人，听了之后，他们到底能获得什么呢？我觉得大部分人其实就是看个热闹。</p><p>当然，也不是说他做的事情完全没有价值。比如说，有些人在选择工具的时候，看到他的测评，了解到这个产品其实没有宣传得那么厉害，可能就不会去用了，对于这点来说，确实有很大的参考价值。</p><p>那你说，这对投资人有价值吗？我觉得可能没有。投资人难道看不到这些问题吗？难道投资人就不懂吗？投资人为什么还会去投这个项目？我觉得，投资人投资的逻辑和咸鱼看产品的逻辑可能根本不是一回事。</p><p>所以说，不管怎么批判这个、批判那个，说得都肯定没错。但我觉得，更重要的是去创造一些东西。即使这个东西前期看起来很烂，但只要它在持续迭代、持续更新，就有可能变好。只要一直往前走，就有可能解决更多问题，给大家带来更多收益。我觉得，这种价值要比在公共场合批判一个产品大得多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="生活记录" scheme="https://maxweber36.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>🧠 如何让大模型变得诚实</title>
    <link href="https://maxweber36.github.io/2025/09/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B9%BB%E8%A7%89/"/>
    <id>https://maxweber36.github.io/2025/09/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B9%BB%E8%A7%89/</id>
    <published>2025-09-06T05:10:30.000Z</published>
    <updated>2025-09-06T06:16:07.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天在看机器之心的公众号上看到一篇文章<a href="https://mp.weixin.qq.com/s/f6pTUhzn9NjA_xWSvTmG4A">《OpenAI 罕见发论文:我们找到了 AI 幻觉的罪魁祸首》</a>。</p><p>在这篇文章中介绍 OpenAI 最近发的一篇论文，名字叫做<a href="https://cdn.openai.com/pdf/d04913be-3f6f-4d2b-b283-ff432ef4aaa5/why-language-models-hallucinate.pdf">《Why Language Models Hallucinate》(为什么语言模型有幻觉)</a>。</p><p>我很好奇，就点进去看了一下。很有意思。原因说起来，很简单。就是 <strong>「标准的训练和评估程序更倾向于对猜测进行奖励，而不是在模型勇于承认不确定时给予奖励」</strong>。</p><p>在 OpenAI 的<a href="https://cdn.openai.com/pdf/d04913be-3f6f-4d2b-b283-ff432ef4aaa5/why-language-models-hallucinate.pdf">这篇论文</a>中，主要想要克服的“幻觉”是「模型不诚实地生成自己都不相信的答案的情况」。</p><p>这句话是我自己看完论文后，自己总结的。</p><p>在 OpenAI 的这篇论文中，主要说了两点。</p><ol><li><p>大模型的预训练逻辑决定——大模型对于问题的回答， 并非 “记忆数据”，而是通过统计规律 “学习语言生成模式”。<br>语言模型的预训练本质是 “自回归预测任务”：给定一段文本的前 N 个词（如 “地球的半径约为”），模型需要从训练数据中学到的 “统计规律” 里，预测第 N+1 个词最可能是什么（如 “6371 千米”）。</p></li><li><p>在大模型微调阶段，当前主流评估的 “二元评分体系”（正确得 1 分、空白 &#x2F;“不知道” 得 0 分）则在微调阶段强化了幻觉，使模型陷入 “为刷分而盲目猜测” 的循环。导致<strong>对 “猜测” 的奖励远胜于 “承认不确定性”</strong>。</p></li></ol><p>简单来说：“标准的训练和评估程序更倾向于对猜测进行奖励，而不是在模型勇于承认不确定时给予奖励。”</p><p>在大模型的微调（如 RLHF、DPO）阶段，本应减少幻觉，但主流评估体系的 “二元评分” 反而强化了猜测行为，形成 “惩罚不确定性的流行病”。</p><blockquote><p>二元评分：对模型输出的结果，进行对或者错的二元评判。采用 “正确得 1 分、空白 &#x2F; 不知道 得 0 分”，模型 “盲目猜测” 的期望得分高于 “承认不知道”。</p></blockquote><p><strong>那么如何改进呢？</strong></p><p>简单来说：<u>让模型 “合理表达不确定” 获得奖励，而非惩罚。</u></p><p>对模型的输出结果评估，简单来说就是引进置信度目标（置信度，也就是结果的可信度）。这里的可信度并非外部的可信度，而是来自于模型自己对于输出的结果的可信程度。可以简单理解，只有当大模型自己对于输出结果的置信度 大于 某个置信度目标值，才对正确结果做回答，否则可以说 I Don’t Know。当然这种有很多的技术性的细节。但是最终目标是让大模型变得更加诚实。</p><p>当然关于幻觉体现是多方面的，而这篇论文关于幻觉的讨论和解决方案也只是其中一个侧面（侧重于 I Don’t Kown）。但是即使是这样，我自己在使用的体验上，依然觉得 GPT5 的可靠性要高于其他模型很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="哲学思考" scheme="https://maxweber36.github.io/tags/%E5%93%B2%E5%AD%A6%E6%80%9D%E8%80%83/"/>
    
    <category term="读论文" scheme="https://maxweber36.github.io/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>🚶‍♀️ 第一次散步时的记录</title>
    <link href="https://maxweber36.github.io/2025/09/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%95%A3%E6%AD%A5%E6%97%B6%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>https://maxweber36.github.io/2025/09/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%95%A3%E6%AD%A5%E6%97%B6%E7%9A%84%E8%AE%B0%E5%BD%95/</id>
    <published>2025-09-04T06:49:26.000Z</published>
    <updated>2025-09-04T07:13:37.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>        <div id="aplayer-UfSBiCmZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-UfSBiCmZ"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Step",              author: "Vampire Weekend",              url: "/music/Step.mp3",              pic: "/music-cover/step-cover.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>我在听许知远的播客，这一期播客的标题叫《与你同行的人》。他提到“纽带”以及一个共同的目标。我觉得，很多时候人与人之间的联系，最好的方式就是通过一些事情把大家连接起来。比如，为了达成某个具体目标，或者完成某件具体的事情，大家因为这个目标而被连接在一起。这种连接，在我看来，是比较理想的。</p><blockquote><p>与你同行的人，比你到达的方向更重要。——————特拉克尔</p></blockquote><p>最近一段时间我一直在做独立开发者，很多事情真的就是一个人在完成。有时候会想起以前在公司里，和同事一起合作、协同完成某件事，那种感受和体验确实很不一样。难免会有些怀念。一个人做事的时候，多少会有点孤独感。这种孤独感在于，你的情绪或者想法，没办法随时找个人沟通，只能自己去消化。</p><p>所以遇到这种情况时，我一般会自言自语，把自己的想法记录下来，然后写到博客里。从某种层面上来说，这既是记录自己的想法和当下的情绪状态，也是在帮助自己梳理思路。有时候回头去看当时的想法，还是觉得挺有意思的。</p><p>毕竟人总会忘记很多事情，所以通过文字记录下来，有时候在未来的某个时刻，当你翻阅这些文字的时候，会想起曾经经历过的那些时光，这其实也挺重要的。</p><p>现在已经九月份了，但成都的天气还是很热。我刚刚看到楼下的桂花已经开始开了，感觉特别好。桂花开的时候，其实也意味着秋天快要到了。虽然从农历节气来看，秋天早就已经到了，但现在的气温有时候还是挺高，所以偶尔还是会觉得有点热。不过，桂花开了，说明天气确实要开始转凉了。<br><img src="/images/first-notes-on-walking/flower.jpeg" alt="Osmanthus flower"></p><p>我们小区其实很舒服，虽然不大，但植被挺多的。有时候走在里面，就像沐浴在丛林中一样，非常惬意。刚才我还看到了一只小鸟，准备把它拍下来。<br><img src="/images/first-notes-on-walking/birds.jpeg" alt="birds"></p><p>我发现门口的柚子长大了很多，不知道能不能吃。在楼下转了一段时间后，我准备上楼了。</p><p>对了，昨天我还给自己定了三个目标。第一个是早点睡觉，保证充足的睡眠；第二个是规律饮食，不要一会儿饱一顿、饿一顿的；第三个是坚持运动锻炼。就给自己立了这三个目标。</p><p>还有关于记录这件事，之前看过很多人分享说，他们在散步的时候灵感特别多，能产生很多想法。我现在因为给自己定了锻炼的目标，最多的方式就是多走路，提高每天的步数。</p><p>在走路的过程中，我发现自己可以记录一些想法。我们小区里有很多树，我好像都没见过，也不知道是什么品种，长得还挺奇特。今天天气很热。</p><p>我现在用语音笔记来记录，使用的是 Get 笔记，但目前没有付费。它的时长比较短，只有十分钟。有时候在记录时，会感觉有点不够用，担心可能有些话没被记录下来，所以在说的时候，还会有点焦虑。哈哈哈。以前我几乎没有边散步边记录的习惯，因此之前大部分想法在十分钟内就能搞定。如果后面散步时记录想法的次数多了，我可能会考虑付费订阅他们的计划，这对我来说很有意义。</p><p>我发现门口的柚子长大了很多，不知道能不能吃。在楼下转了一段时间了，我准备上楼了。<br><img src="/images/first-notes-on-walking/fruit.jpeg" alt="fruit"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="生活记录" scheme="https://maxweber36.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
    <category term="个人成长" scheme="https://maxweber36.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
</feed>
